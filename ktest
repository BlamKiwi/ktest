#!/bin/bash -e

KTESTDIR=$(dirname $(readlink -f $0))
VMSTART=$KTESTDIR/vm-start

. $KTESTDIR/util.sh

NJOBS=$((`grep ^processor /proc/cpuinfo |wc -l` * 2))

DIR=".ktest"

KERNEL_SOURCE="."
KERNEL_OUTPUT=""

do_make()
{
    make -C "$KERNEL_SOURCE" O="$KERNEL_OUTPUT" -j "$NJOBS"	\
	INSTALL_MOD_PATH=modules				\
	EXTRA_CFLAGS="-gdwarf-4 -g3 -fvar-tracking -fvar-tracking-assignments" $@
}

check_timeout()
{
    set +e
    sleep $1
    $VMSTART stop `cat $KERNEL_OUTPUT/id`
    kill $$
}

control_c()
{
    echo "USER HIT ^C"
    $VMSTART stop `cat $KERNEL_OUTPUT/id`
    kill $$
}

cmd_run()
{
    IMG=""
    BUILD=1
    NEED_SUDO=""

    run_usage()
    {
	echo "ktest run: Run a kernel test"
	echo "Usage: ktest run [options] test"
	echo "	-k	kernel source dir"
	echo "	-K	don't build kernel"
	echo "	-i	VM root filesystem image"
	echo "	-t	timout in seconds"
	echo "	-b	bld directory for kernel"
	echo "	-j	j option to make"
    }

    while getopts "hKb:k:i:t:j:" arg; do
	case $arg in
	    h)
		run_usage
		exit 0
		;;
	    k)
		KERNEL_SOURCE=`realpath "$OPTARG"`
		;;
	    K)
		BUILD=""
		;;
	    i)
		IMG=$OPTARG
		;;
	    t)
		TIMEOUT=$OPTARG
		;;
	    b)
		KERNEL_OUTPUT=$OPTARG
		;;
	    j)
		NJOBS=$OPTARG
		;;
	esac
    done
    shift $(( OPTIND - 1 ))

    if [ ! -n "$KERNEL_OUTPUT" ] ; then
       KERNEL_OUTPUT="$KERNEL_SOURCE/$DIR"
    fi

    kconfig="$KERNEL_OUTPUT/.config"
    config_tool="$KERNEL_SOURCE/scripts/config"

    if [ "$IMG" = "" ] ; then
	if [ -f "/var/lib/ktest/root" ]; then
	    IMG="/var/lib/ktest/root"
	elif [ -f "$HOME/.ktest/root" ]; then
	    IMG="$HOME/.ktest/root"
	else
	    echo "VM root filesystem not found, please create /var/lib/ktest/root or"
	    echo "$HOME/.ktest/root"
	    exit 1
	fi
    fi
    if [ ! -f $IMG ] ; then
	echo "VM root filesystem not found, use vm_create_image to create one"
	exit 1
    fi

    TEST=$1
    if [ -z "$TEST" ]; then
	echo "ktest: missing test"
	run_usage
	exit 1
    fi

    if [ ! -f "$TEST" ]; then
	echo "Test $TEST not found"
	exit 1
    fi

    TEST=`realpath "$TEST"`

    eval `$TEST deps`

    if [ -z "$MEM" ]; then
	echo "test must specify requirements"
	exit 1
    fi

    mkdir -p $KERNEL_OUTPUT
    rm -f $KERNEL_OUTPUT/rc
    cp -f $TEST $KERNEL_OUTPUT/rc
    FILES=$KERNEL_OUTPUT/rc
    TESTDIR=`dirname $TEST`

    OLDIFS=$IFS
    IFS=','
    PATH+=":/sbin:/usr/sbin:/usr/local/sbin"

    for req in $REQUIRE; do
	if [ -e "$TESTDIR/$req" ]; then
	    FILES+=" `realpath $TESTDIR/$req`"
	elif f="`which $req`"; then
	    FILES+=" `realpath $f`"
	else
	    echo "Dependency $req not found"
	    exit 1
	fi
    done

    for req in $LREQUIRE; do
	if [ ! -e "$req" ]; then
	    echo "Dependency $req not found"
	    exit 1
	fi
	FILES+=" `realpath $req`"
    done
   
    sudo rm -rf container
    for req in $CONTAINER; do
        mkdir -p container
	if [ ! -e "$req" ]; then
	    echo "Container $req not found"
	    exit 1
	fi
        cname=`basename "$req" .tar.gz`
        sudo tar xz -C container -f "$req"
        if [ ! -d "container/$cname" ] ; then
           echo "Container '$req' does not unpack into expected directory '$cname'"
           exit 1
        fi
    done
    if [ -d container ] ; then
	FILES+=" container"
        NEED_SUDO=sudo
    fi


    if [ -n "$BUILD" ]; then
	[ -f "$kconfig" ] || cp "$KTESTDIR/defconfig" "$kconfig"

	for req in $KERNEL_CONFIG_REQUIRE; do
	    "$config_tool" --file "$kconfig" -e $req
	done

	do_make oldconfig
    fi

    for req in $KERNEL_CONFIG_REQUIRE; do
	if [ `"$config_tool" --file "$kconfig" -s $req` != "y" ]; then
	    echo "Kernel config option $req not set"
	    exit 1
	fi
    done

    IFS=$OLDIFS

    if [ -n "$BUILD" ]; then
	do_make || exit 1
    fi

    do_make modules_install

    # Remove symlinks, they'll break genisoimage which is following symlinks
    rm -f $KERNEL_OUTPUT/modules/lib/modules/*/build
    rm -f $KERNEL_OUTPUT/modules/lib/modules/*/source

    $NEED_SUDO genisoimage -quiet -R -input-charset utf-8	\
	-o $KERNEL_OUTPUT/run.iso 			\
	$KERNEL_OUTPUT/modules/lib $FILES || exit 1
    test -n "$BUILD" && rm -rf $KERNEL_OUTPUT/modules

    if [ -n "$TIMEOUT" ]; then
	check_timeout "$TIMEOUT" &
	ALARM=$!
    fi

    stty -a
    trap control_c SIGINT
    $VMSTART start				\
	-i $IMG -t $TMPDIR			\
	-k "$KERNEL_OUTPUT/arch/x86/boot/bzImage"\
	-c $KERNEL_OUTPUT/run.iso		\
	--id $KERNEL_OUTPUT/id			\
	-m "$MEM"				\
	-s "$SCRATCH"				\
	 |{
	sed -e '/TEST SUCCESS/q'
	set +e
	[ -n "$ALARM" ] && kill $ALARM 2> /dev/null
	$VMSTART stop `cat $KERNEL_OUTPUT/id`
	stty sane 2> /dev/null  || true
	exit 0
    }
    trap SIGINT
    stty sane 2> /dev/null || true
}

cmd_ssh()
{
    exec $VMSTART ssh `cat $KERNEL_OUTPUT/id`
}

cmd_gdb()
{
    exec $VMSTART gdb `cat $KERNEL_OUTPUT/id` $KERNEL_OUTPUT/vmlinux
}

cmd_mon()
{
    exec $VMSTART mon `cat $KERNEL_OUTPUT/id`
}

cmd_oldconfig()
{
    do_make oldconfig
}

cmd_config()
{
    do_make nconfig
}

usage()
{
    echo "ktest: Test kernels in virtual machines on a pool of remote servers"
    echo "Usage: ktest cmd [n]"
    echo "  run [-t timeut] [-i vmimage ] <testfile>	Compile and run a kernel and run <testfile>"
    echo "  ssh		Log in as root"
    echo "  gdb		Connect to kgdb"
    echo "  mon		Connect to qemu monitor"
    echo "  oldconfig	Run make oldconfig"
    echo "  config	Run make nconfig"
}

CMD="cmd_$1"
if [ -z "$1" -o "`type -t "$CMD"`" != "function" ]; then
    usage
    exit 1
fi
shift


if [ -d "$HOME/.ktest/tmp" ]; then
    TMPDIR=$HOME/.ktest/tmp
else
    TMPDIR=/tmp
fi

set -x
checkdep realpath
checkdep genisoimage
checkdep minicom
checkdep socat
checkdep gcc
checkdep make
checkdep qemu-system-x86_64 qemu-system-x86

eval $CMD $@
