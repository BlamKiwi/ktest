#!/bin/bash

set -o nounset
set -o errexit
set -o errtrace
shopt -s lastpipe

# check for typical shell script errors

export PS4='+${LINENO}+ '

KTESTDIR=$(dirname "$(readlink -f "$0")")
VMSTART=("$KTESTDIR/vm-start")

. "$KTESTDIR/util.sh"
. "$KTESTDIR/parse-test.sh"

checkdep genisoimage
checkdep minicom
checkdep socat
checkdep qemu-system-x86_64 qemu-system-i386

PRIORITY=0		# hint for how long test should run
IMG=""			# root image that will be booted
                        #       set with: -i <path>
                        #       defaults: /var/lib/ktest/root
                        #       auto-override: $HOME/.ktest/root
KERNEL=""		# dir that has the kernel to run
                        #       set with: -k <path>
IDFILE=""		# passed as --id to vmstart
                        #       set with: -w <path>
SCRATCHDIR=""
OUTPUT_DIR=""		# dir for test output (logs, code coverage, etc.)
VM_TMPDIR="/tmp"	# dir where scratch drives are created
                        #       defaults: /tmp
                        #       auto-override: $HOME/.ktest/tmp
INTERACTIVE=0           # if set to 1, timeout is ignored completely
                        #       sets with: -I
EXIT_ON_SUCCESS=0	# if true, exit on success, not failure or timeout
VERBOSE=0		# if false, append quiet to kernel commad line

# config files:
[[ -f $KTESTDIR/ktestrc ]]	&& . "$KTESTDIR/ktestrc"
[[ -f /etc/ktestrc ]]		&& . /etc/ktestrc

[[ -f $HOME/.ktestrc ]]		&& . "$HOME/.ktestrc"
[[ -f $HOME/.ktest/root ]]	&& IMG="$HOME/.ktest/root"
[[ -d $HOME/.ktest/tmp ]]	&& VM_TMPDIR="$HOME/.ktest/tmp"

usage()
{
    echo "ktest: Run generic virtual machine tests"
    echo "Usage: ktest cmd [options]"
    echo "  boot        Boot a VM without running anything"
    echo "  run <test>  Run a kernel test"
    echo "  ssh         Login as root"
    echo "  gdb         Connect to qemu's gdb interface"
    echo "  kgdb        Connect to kgdb"
    echo "  mon         Connect to qemu monitor"
    echo "  sysrq <key> Send magic sysrq key via monitor"
    echo
    echo "  options:"
    echo "      -x       bash debug statements"
    echo "      -k <dir> kernel to use (default: kernel_source/.ktest)"
    echo "      -w <dir> work directory (default: .ktest"
    echo "      -o <dir> output directory (default: ktest-out)"
    echo
    echo " options for ktest run:"
    echo "      -i <dir> VM root filesystem image"
    echo "      -p <num> hint for test duration (higher is longer, default is 0)"
    echo "      -I       don't automatically stop VM"
    echo "      -S       exit only on test success"
    echo
    echo "For kgdb to be enabled, either -I or -S must be specified"
}

if [[ $# = 0 ]]; then
    usage
    exit 1
fi

#parse command and shift for rest of arg parsing
CMD="cmd_$1"
shift

while getopts "ha:p:i:k:ISw:s:o:vx" arg; do
    case $arg in
	h)
	    usage
	    exit 0
	    ;;
	a)
	    ARCH=$OPTARG
	    ;;
	p)
	    PRIORITY=$OPTARG
	    ;;
	i)
	    IMG=$OPTARG
	    ;;
	k)
	    KERNEL=$OPTARG
	    ;;
	w)
	    IDFILE="$OPTARG"
	    ;;
	s)
	    SCRATCHDIR="$OPTARG"
	    ;;
	o)
	    OUTPUT_DIR="$OPTARG"
	    ;;
	I)
	    INTERACTIVE=1
	    ;;
	S)
	    EXIT_ON_SUCCESS=1
	    ;;
	v)
	    VERBOSE=1
	    ;;
	x)
	    set -x
	    ;;
    esac
done
shift $(( OPTIND - 1 ))

if [[ -z $KERNEL ]]; then
    echo "Required parameter -k missing: kernel to boot"
    exit 1
fi

parse_arch "$ARCH"

[[ -z $IMG ]]		&& IMG=/var/lib/ktest/root.$DEBIAN_ARCH
[[ -z $IDFILE ]]	&& IDFILE=./.ktest-vm
[[ -z $OUTPUT_DIR ]]	&& OUTPUT_DIR=./ktest-out

VMSTART+=("--idfile" "$IDFILE")
VMSTART+=("--tmpdir" "$VM_TMPDIR")

run_vm()
{
    if [[ ! -f $IMG ]]; then
	echo "VM root filesystem not found, use vm_create_image to create one"
	exit 1
    fi

    VMSTART+=("start")

    [[ -n $SCRATCHDIR ]] && VMSTART+=("--scratchdir" "$SCRATCHDIR")

    if [[ $EXIT_ON_SUCCESS = 1 || $INTERACTIVE = 1 ]]; then
	case $KERNEL_ARCH in
	    x86)
		VMSTART+=("--kgdb")
		;;
	esac
    fi

    # setup directory where logfs will be mounted from
    mkdir -p "$OUTPUT_DIR"

    # kernel modules
    FILES+=("$KERNEL/lib")

    # kernel to kexec to for crash dumps
    FILES+=("vmlinuz=$KERNEL/vmlinuz")

    get_tmpdir

    local iso="$TMPDIR/ktest.iso"
    genisoimage -quiet -graft-points -input-charset utf-8 -R		\
	-o "$iso" "${FILES[@]}"

    set +o errexit

    if [[ $EXIT_ON_SUCCESS = 0 && $INTERACTIVE = 0 ]]; then
	_KERNEL_APPEND="$_KERNEL_APPEND ktest.timeout=$_TIMEOUT"
    fi

    if [[ $VERBOSE = 0 ]]; then
	_KERNEL_APPEND="$_KERNEL_APPEND quiet"
    fi

    "${VMSTART[@]}"							\
	--architecture="${QEMU_BIN#qemu-system-}"			\
	--image="$IMG"							\
	--kernel="$KERNEL/vmlinuz"					\
	--cdrom="$iso"							\
	--fs "$OUTPUT_DIR" logfs					\
	--append="ktest.priority=$PRIORITY"				\
	--append="log_buf_len=8M"					\
	--append="$_KERNEL_APPEND"					\
	--memory="$_MEM"						\
	--cpus "$_CPUS"							\
	--nr_vms="$_NR_VMS"						\
	"${_VMSTART_ARGS[@]}"|
    {
	if [[ $INTERACTIVE = 1 ]]; then
	    cat
	elif [[ $EXIT_ON_SUCCESS = 1 ]]; then
	    sed -u -e '/TEST SUCCESS/ { p; Q7 }'
	else
	    timeout "$((60 + _TIMEOUT))" $KTESTDIR/catch_test_success.awk
	fi

	ret=$?
	kill %1
    }

    if [[ $ret = 124 ]]; then
	echo 'TEST TIMEOUT'
	exit 1
    fi

    # don't want sed exiting normally (saw neither TEST SUCCESS nor TEST FAILED)
    # to be consider success:
    [[ $ret = 7 ]]
}

cmd_boot()
{
    INTERACTIVE=1
    _KERNEL_APPEND=""
    _MEM=1G
    _CPUS=6
    _NR_VMS=1
    _VMSTART_ARGS=()

    FILES=("rc=$KTESTDIR/rc.interactive")

    run_vm
}

cmd_run()
{
    if [[ $# = 0 ]]; then
	echo "ktest: missing test"
	exit 1
    fi

    local TEST=$(readlink -e "$1")

    FILES=("rc=$KTESTDIR/rc.testwrapper")
    FILES+=("rc.interactive=$KTESTDIR/rc.interactive")
    FILES+=("rc.test=$TEST")

    parse_test_deps "$TEST"
    run_vm "$TEST"
}

cmd_ssh()
{
    exec "${VMSTART[@]}" ssh "$@"
}

cmd_gdb()
{
    exec "${VMSTART[@]}" gdb "$KERNEL/vmlinux"
}

cmd_kgdb()
{
    exec "${VMSTART[@]}" kgdb "$KERNEL/vmlinux"
}

cmd_mon()
{
    exec "${VMSTART[@]}" mon
}

cmd_sysrq()
{
    exec "${VMSTART[@]}" sysrq "$@"
}

# checks if command is valid
if [[ $(type -t "$CMD") != function ]]; then
    usage
    exit 1
fi

$CMD "$@"
