#!/bin/bash -e

KTESTDIR=$(dirname $(readlink -f $0))
VMSTART=$KTESTDIR/vm-start
INTERACTIVE=0

. $KTESTDIR/util.sh

NJOBS=$((`grep ^processor /proc/cpuinfo |wc -l` * 2))

DIR=".ktest"

KERNEL_SOURCE="."
KERNEL_OUTPUT=""

export PS4='+${LINENO}+ '

trap 'stty sane > /dev/null 2>&1 || true' EXIT

do_make()
{
    make -C "$KERNEL_SOURCE" O="$WORK_DIRECTORY" -j "$NJOBS"	\
	INSTALL_MOD_PATH=modules				\
	EXTRA_CFLAGS="-gdwarf-4 -g3 -fvar-tracking -fvar-tracking-assignments" $@
}


check_mlxcard()
{
    ret=0
    line=`lspci | grep Mellanox`
    if [ -n "$line" ]
    then
	sudo $VMSTART genconx3 > /dev/null 2>&1
	ret=1
    fi
    echo $ret
}


check_timeout()
{
    set +e
    sleep $1
    $2 $VMSTART stop `cat $WORK_DIRECTORY/id`
    stty sane 2> /dev/null || true
    kill $$
}

build_kernel()
{
    KERNEL_SOURCE=$1
    KERNEL_OUTPUT=$2
    KERNEL_CONFIG_REQUIRE=$3

    kconfig="$KERNEL_OUTPUT/.config"
    config_tool="$KERNEL_SOURCE/scripts/config"

    OLDIFS=$IFS
    IFS=','

    if [ -n "$BUILD" ]; then
	[ -f "$kconfig" ] || cp "$KTESTDIR/defconfig" "$kconfig"

	for req in $KERNEL_CONFIG_REQUIRE; do
	    "$config_tool" --file "$kconfig" -e $req
	done

	do_make oldconfig
    fi

    for req in $KERNEL_CONFIG_REQUIRE; do
        c=`"$config_tool" --file "$kconfig" -s $req`
	if [ "$c" != "y" ]; then
	    echo "Kernel config option $req not set"
	    exit 1
	fi
    done

    IFS=$OLDIFS

    if [ -n "$BUILD" ]; then
	do_make || exit 1
    fi

    do_make modules_install
}

cmd_run()
{
    IMG=""
    NEED_SUDO=""

    if [ "$IMG" = "" ] ; then
	if [ -f "/var/lib/ktest/root" ]; then
	    IMG="/var/lib/ktest/root"
	elif [ -f "$HOME/.ktest/root" ]; then
	    IMG="$HOME/.ktest/root"
	else
	    echo "VM root filesystem not found, please create /var/lib/ktest/root or"
	    echo "$HOME/.ktest/root"
	    exit 1
	fi
    fi
    if [ ! -f $IMG ] ; then
	echo "VM root filesystem not found, use vm_create_image to create one"
	exit 1
    fi

    TEST=$1
    if [ -z "$TEST" ]; then
	echo "ktest: missing test"
	usage
	exit 1
    fi

    if [ ! -f "$TEST" ]; then
	echo "Test $TEST not found"
	exit 1
    fi

    TEST=`realpath "$TEST"`

    eval `$TEST deps`

    if [ -z "$MEM" ]; then
	echo "test must specify requirements"
	exit 1
    fi

    mkdir -p $WORK_DIRECTORY
    rm -f $WORK_DIRECTORY/rc
    cp -f $TEST $WORK_DIRECTORY/rc
    if [ "$INTERACTIVE" = 1 ] ; then
       echo /bin/bash >> $WORK_DIRECTORY/rc
       echo "echo o > /proc/sysrq-trigger" >> $WORK_DIRECTORY/rc
    fi
    FILES=$WORK_DIRECTORY/rc
    TESTDIR=`dirname $TEST`

    OLDIFS=$IFS
    IFS=','
    PATH+=":/sbin:/usr/sbin:/usr/local/sbin"

    for req in $REQUIRE; do
	if [ -e "$TESTDIR/$req" ]; then
	    FILES+=" `realpath $TESTDIR/$req`"
	elif f="`which $req`"; then
	    FILES+=" `realpath $f`"
	else
	    echo "Dependency $req not found"
	    exit 1
	fi
    done

    for req in $LREQUIRE; do
	if [ ! -e "$req" ]; then
	    echo "Dependency $req not found"
	    exit 1
	fi
	FILES+=" `realpath $req`"
    done
   
    if [ -n "$CONTAINER" ]; then
        containerdir="$WORK_DIRECTORY/container"
	sudo rm -rf $containerdir
	for req in $CONTAINER; do
	    mkdir -p $containerdir
	    if [ ! -e "$req" ]; then
		echo "Container $req not found"
		exit 1
	    fi
	    cname=`basename "$req" .tar.gz`
	    sudo tar xz -C $containerdir -f "$req"
	    if [ ! -d "$containerdir/$cname" ] ; then
		echo "Container '$req' does not unpack into expected directory '$cname'"
		exit 1
	    fi
	done
	if [ -d $containerdir ] ; then
	    FILES+=" $containerdir"
	    NEED_SUDO=sudo
	fi
    fi

    IFS=$OLDIFS

    build_kernel $KERNEL_SOURCE $KERNEL_OUTPUT $KERNEL_CONFIG_REQUIRE

    # Remove symlinks, they'll break genisoimage which is following symlinks
    rm -f $WORK_DIRECTORY/modules/lib/modules/*/build
    rm -f $WORK_DIRECTORY/modules/lib/modules/*/source

    $NEED_SUDO genisoimage -quiet -R -input-charset utf-8	\
	-o $WORK_DIRECTORY/run.iso 			\
	$WORK_DIRECTORY/modules/lib $FILES || exit 1
    rm -rf $WORK_DIRECTORY/modules

    vmstart_command="$VMSTART start			\
	-i $IMG -t $TMPDIR				\
	-k "$KERNEL_OUTPUT/arch/x86/boot/bzImage"	\
	-c $WORK_DIRECTORY/run.iso			\
	--id $WORK_DIRECTORY/id				\
	-m "$MEM"					\
	-s "$SCRATCH"					\
	$VDE"

    vmsudo=""
    if [ -n "$INFINIBAND" ]; then
	ret=$(check_mlxcard)
	if [ "$ret" -eq 1 ]; then
	    vmstart_command="sudo $vmstart_command --conx3"
            vmsudo=sudo
	fi
    fi

    if [ -n "$TIMEOUT" ]; then
	check_timeout "$TIMEOUT" "$vmsudo" &
	ALARM=$!
    fi


    if [ "$INTERACTIVE" = 1 ] ; then
	$vmstart_command
    else
	$vmstart_command|{
           sed -e '/TEST SUCCESS/q'
           set +e
           [ -n "$ALARM" ] && kill $ALARM 2> /dev/null
           $vmsudo $VMSTART stop `cat $WORK_DIRECTORY/id`
           stty sane 2> /dev/null  || true
           exit 0
       }
    fi
    trap SIGINT
    stty sane 2> /dev/null || true
}

cmd_ssh()
{
    $VMSTART ssh `cat $WORK_DIRECTORY/id` "$@"
}

cmd_stop()
{
    exec $VMSTART ssh `cat $WORK_DIRECTORY/id`
}

cmd_gdb()
{
    exec $VMSTART gdb `cat $WORK_DIRECTORY/id` $KERNEL_OUTPUT/vmlinux
}

cmd_kgdb()
{
    exec $VMSTART kgdb `cat $WORK_DIRECTORY/id` $KERNEL_OUTPUT/vmlinux
}

cmd_mon()
{
    exec $VMSTART mon `cat $WORK_DIRECTORY/id`
}

cmd_lcov()
{
    checkdep lcov

    gcov_in=/sys/kernel/debug/gcov/`realpath $KERNEL_OUTPUT`
    gcov_out=$WORK_DIRECTORY/gcov
    info=$WORK_DIRECTORY/gcov.info
    html=$WORK_DIRECTORY/gcov.html

    mkdir -p $gcov_out

    cmd_ssh mkdir -p /tmp/gcov
    cmd_ssh cp -a "$gcov_in/*" /tmp/gcov
    cmd_ssh "(cd /tmp/gcov; tar cf - .)"    \
	|(cd "$gcov_out"; tar xf -)

    lcov --directory "$gcov_out" --capture --output-file $info
    genhtml --output-directory $html $info

    echo
    echo "LCOV report:"
    echo    file://$html/index.html
}

cmd_oldconfig()
{
    do_make oldconfig
}

cmd_config()
{
    do_make nconfig
}

usage()
{
    echo "ktest: Test kernels in virtual machines on a pool of remote servers"
    echo "Usage: ktest cmd [options] [n]"
    echo "  run [options]: Run a kernel test"
    echo "  ssh		Log in as root"
    echo "  gdb		Connect to kgdb"
    echo "  mon		Connect to qemu monitor"
    echo "  oldconfig	Run make oldconfig"
    echo "  config	Run make nconfig"
    echo
    echo "  options:"
    echo "	-x bash debug statements"
    echo "	-k	kernel source dir"
    echo "	-b	bld directory for kernel (default: kernel_source/.ktest)"
    echo "	-w	work director (default: kernel build directory)"
    echo "	-K	don't build kernel (run cmd only)"
    echo "	-i	VM root filesystem image (run cmd only)"
    echo "	-t	timout in seconds (run cmd only)"
    echo "	-j	j option to make (run cmd only)"
    echo "	-I	interactive run (run cmd only)"
    echo "	-v run with vde networking (run cmd only)"
}

CMD="cmd_$1"
if [ -z "$1" -o "`type -t "$CMD"`" != "function" ]; then
    usage
    exit 1
fi
shift
BUILD=1
WORK_DIRECTORY=""

while getopts "IhKb:k:i:t:j:w:vx" arg; do
    case $arg in
	h)
	    usage
	    exit 0
	    ;;
	k)
	    KERNEL_SOURCE=`realpath "$OPTARG"`
	    ;;
	K)
	    BUILD=""
	    ;;
	i)
	    IMG=$OPTARG
	    ;;
	t)
	    TIMEOUT=$OPTARG
	    ;;
	b)
	    KERNEL_OUTPUT=$OPTARG
	    ;;
	j)
	    NJOBS=$OPTARG
	    ;;
	I)
	    INTERACTIVE=1
	    ;;
	w)
	    WORK_DIRECTORY=$OPTARG
	    ;;
	x)
	    set -x
	    ;;
	v)
	    VDE="--vde"
	    ;;
    esac
done
shift $(( OPTIND - 1 ))

if [ -z "$KERNEL_OUTPUT" ]; then
    KERNEL_OUTPUT="$KERNEL_SOURCE/$DIR"
fi
if [ -z "$WORK_DIRECTORY" ] ; then
   WORK_DIRECTORY=$KERNEL_OUTPUT
fi
mkdir -p "$WORK_DIRECTORY"
WORK_DIRECTORY=`realpath "$WORK_DIRECTORY"`

if [ -d "$HOME/.ktest/tmp" ]; then
    TMPDIR=$HOME/.ktest/tmp
else
    TMPDIR=/tmp
fi

checkdep realpath
checkdep genisoimage
checkdep minicom
checkdep socat
checkdep gcc
checkdep make
checkdep qemu-system-x86_64 qemu-system-i386

eval $CMD $@
