#!/bin/bash

set -o nounset
set -o errexit
set -o errtrace

# check for typical shell script errors

export PS4='+${LINENO}+ '

KTESTDIR=$(dirname "$(readlink -f "$0")")
VMSTART=$KTESTDIR/vm-start

. "$KTESTDIR/util.sh"
. "$KTESTDIR/parse-test.sh"

if which shellcheck > /dev/null 2>&1; then
    shellcheck "$0"
    shellcheck "$KTESTDIR/util.sh"
    shellcheck -exclude=SC2034 "$KTESTDIR/parse-test.sh"
fi

checkdep genisoimage
checkdep minicom
checkdep socat
checkdep qemu-system-x86_64 qemu-system-i386

PRIORITY="0"		# hint for how long test should run
KERNEL=""		# dir that has the kernel to run
                        #       set with: -k <path>
WORK_DIR=""             # dir where vm meta data (id, logs, etc) gets stored
                        #       set with: -w <path>
LOG_INTERNAL="log.internal"
                        # dir name which is mapped with virtfs to inside vm
                        # at /var/log/datera
                        #       path: $WORK_DIR/$LOG_INTERNAL
SCRATCH_DIR="/tmp"      # dir where scratch drives are created
                        #       defaults: /tmp
                        #       auto-override: $HOME/.ktest/tmp
IMG="/var/lib/ktest/root"
                        # root image that will be booted
                        #       set with: -i <path>
                        #       defaults: /var/lib/ktest/root
                        #       auto-override: $HOME/.ktest/root
INTERACTIVE=0           # if set to 1, timeout is ignored completely
                        #       sets with: -I
EXIT_ON_SUCCESS=0	# if true, exit on success, not failure or timeout
CONTAINER_SRC_DIR=""	# dir which contains the datera containers

# config files:
[ -f "$KTESTDIR/ktestrc" ]	&& . "$KTESTDIR/ktestrc"
[ -f /etc/ktestrc ]		&& . /etc/ktestrc
[ -f "$HOME/.ktestrc" ]		&& . "$HOME/.ktestrc"

# root image auto-override
if [ -f "$HOME/.ktest/root" ]; then
    IMG="$HOME/.ktest/root"
fi

# scratch drive dir auto-override
if [ -d "$HOME/.ktest/tmp" ]; then
    SCRATCH_DIR=$HOME/.ktest/tmp
fi

usage()
{
    echo "ktest: Run generic virtual machine tests"
    echo "Usage: ktest cmd [options]"
    echo "  boot        Boot a VM without running anything"
    echo "  run <test>  Run a kernel test"
    echo "  ssh         Login as root"
    echo "  gdb         Connect to kgdb"
    echo "  mon         Connect to qemu monitor"
    echo
    echo "  options:"
    echo "      -x       bash debug statements"
    echo "      -k <dir> build directory for kernel (default: kernel_source/.ktest)"
    echo "      -w <dir> work directory (default: kernel build directory)"
    echo "      -i <dir> VM root filesystem image (run cmd only)"
    echo "      -I       disable timeout and VM stop on pass/fail (run cmd only)"
}

#prints usage if no args
if [[ $# -lt 1 ]]; then
    usage
    exit 1
fi

#parse command and shift for rest of arg parsing
CMD="cmd_$1"
shift

while getopts "hp:i:k:ISw:x" arg; do
    case $arg in
	h)
	    usage
	    exit 0
	    ;;
	p)
	    PRIORITY=$OPTARG
	    ;;
	i)
	    IMG=$OPTARG
	    ;;
	k)
	    KERNEL=$OPTARG
	    ;;
	I)
	    INTERACTIVE=1
	    ;;
	S)
	    EXIT_ON_SUCCESS=1
	    ;;
	w)
	    WORK_DIR=$OPTARG
	    ;;
	x)
	    set -x
	    ;;
    esac
done
shift $(( OPTIND - 1 ))

if [ -z "$KERNEL" ]; then
    echo "Required parameter -k missing: kernel to boot"
    exit 1
fi

[ -z "$WORK_DIR" ] && WORK_DIR="./ktest.$$"

mkdir -p "$WORK_DIR"
WORK_DIR=$(readlink -e "$WORK_DIR")

trap 'stty sane > /dev/null 2>&1 || true' EXIT

check_mlxcard()
{
    if ! $VMSTART check conx3; then
	echo "no free infiniband card present"
	exit 1
    fi
}

build_file_list()
{
    if [ $# -eq 0 ]; then
	install -m0755 "$KTESTDIR/rc.interactive" "$WORK_DIR/rc"
	FILES="$WORK_DIR/rc"
	_MEM="1G"
    else
	TEST=$1
	TEST=$(readlink -e "$TEST")

	install -m0755 "$KTESTDIR/rc.testwrapper" "$WORK_DIR/rc"
	FILES="$WORK_DIR/rc"

	install -m0644 "$TEST" "$WORK_DIR/rc.test"
	FILES+=" $WORK_DIR/rc.test"

	parse_test_deps "$TEST"

	if [ -n "$_INFINIBAND" ]; then
	    VMSTART="sudo $VMSTART"
	    check_mlxcard
	fi

	local containerdir="$WORK_DIR/container"

	if [ -n "$_CONTAINERS" ]; then
	    FILES+=" $containerdir"
	    genisoimage_sudo=sudo
	    sudo rm -rf "$containerdir"
	    mkdir -p "$containerdir"
	fi

	for req in $_CONTAINERS; do
	    local cvf="$CONTAINER_SRC_DIR/${req}.version.txt"

	    if [ ! -e "$cvf" ]; then
		echo "Container version file not found: $cvf"
		exit 1
	    fi

	    local cv=$(cat "$cvf")
	    local cf="$CONTAINER_SRC_DIR/${req}-${cv}.tar.gz"

	    if [ ! -e "$cf" ]; then
		echo "Container file not found: $cf"
		exit 1
	    fi

	    local cdir="${req}-${cv}"
	    local containerdir="$WORK_DIR/container"

	    sudo tar xz -C "$containerdir" -f "$cf"
	    if [ ! -d "$containerdir/$cdir" ]; then
		echo "Container '$req' does not unpack into expected directory '$cdir'"
		exit 1
	    fi
	    sudo ln -s "$cdir" "${containerdir}/${req}.chroot"
	done
    fi
}

prepare_vm()
{
    if [ ! -f "$IMG" ] ; then
	echo "VM root filesystem not found, use vm_create_image to create one"
	exit 1
    fi

    # Might be overridden by test script
    genisoimage_sudo=""

    # setup directory where logfs will be mounted from
    rm -rf "$WORK_DIR/$LOG_INTERNAL"
    mkdir -p "$WORK_DIR/$LOG_INTERNAL"

    build_file_list "$@"

    # shellcheck disable=SC2086
    $genisoimage_sudo genisoimage -quiet -R		\
	-input-charset utf-8				\
	-o "$WORK_DIR/run.iso"				\
	"$KERNEL/lib" $FILES || exit 1

    if [ -n "$genisoimage_sudo" ]; then
	$genisoimage_sudo chown "$USER" "$WORK_DIR/run.iso"
    fi
}

run_lcov()
{
    which lcov >/dev/null 2>&1 || return 0

    [ -d "$WORK_DIR/$LOG_INTERNAL/gcov.0" ] || return 0

    local gcov_out=$WORK_DIR/gcov

    rm -rf "$gcov_out"
    mkdir "$gcov_out"

    local info=$gcov_out/gcov.info
    local html=$gcov_out/gcov.html
    local tracefiles=""

    for i in $WORK_DIR/$LOG_INTERNAL/gcov.*; do
        local out=$gcov_out/$(basename "$i").info
	tracefiles+=" --add-tracefile $out"

	lcov --capture --quiet				\
	    --directory "$i" --output-file "$out"
    done

    [ -n "$tracefiles" ] || return 0

    echo "You may need to install perl-digest-MD5 for lcov"
    echo "    sudo yum install perl-Digest-MD5"

    # shellcheck disable=SC2086
    lcov --quiet --output-file "$info" $tracefiles || true
    genhtml --output-directory "$html" "$info" > /dev/null || true

    echo
    echo "LCOV report: file://$html/index.html"
}

run_vmstart()
{
    # shellcheck disable=SC2086
    $VMSTART start					\
	-i "$IMG" -t "$SCRATCH_DIR"			\
	-k "$KERNEL/vmlinuz"				\
	-c "$WORK_DIR/run.iso"				\
	--id "$WORK_DIR/id"				\
	--fs "$WORK_DIR/$LOG_INTERNAL" logfs		\
        "$@"
}

cmd_boot()
{
    prepare_vm

    run_vmstart -m 1G --kgdb --cpus 6
}

cmd_run()
{
    local KGDB=""

    if [[ $# -lt 1 ]]; then
	echo "ktest: missing test"
	exit 1
    fi

    prepare_vm "$1"

    rm -f "$WORK_DIR/output"
    mkfifo "$WORK_DIR/output"

    [ "$EXIT_ON_SUCCESS" = 1 -o "$INTERACTIVE" = 1 ] && KGDB="--kgdb"

    # shellcheck disable=SC2086
    run_vmstart                                                 \
	--append="root=/dev/sda rw ktest.priority=$PRIORITY"	\
	$KGDB							\
	-m "$_MEM"						\
	--cpus "$_CPUS"						\
	$_SCRATCH						\
	$_INFINIBAND						\
	$_VMCLUSTER </dev/null 2>&1 > "$WORK_DIR/output" &

    err=0

    if [ "$EXIT_ON_SUCCESS" = 1 ]; then
	sed -u -e '/TEST SUCCESS/ { p; Q0 }'			\
	       < "$WORK_DIR/output" || err=1
    elif [ "$INTERACTIVE" = 1 ]; then
	cat "$WORK_DIR/output"
    else
	timeout "$_TIMEOUT"					\
	    sed -u -e '/TEST SUCCESS/ { p; Q0 }'		\
		   -e '/TEST FAILED/  { p; Q1 }'		\
		   < "$WORK_DIR/output" || err=1
    fi

    $VMSTART stop "$(cat "$WORK_DIR/id")"

    run_lcov

    exit $err
}

cmd_ssh()
{
    $VMSTART ssh "$(cat "$WORK_DIR/id")" "$@"
}

cmd_stop()
{
    exec "$VMSTART" ssh "$(cat "$WORK_DIR/id")"
}

cmd_gdb()
{
    exec "$VMSTART" gdb "$(cat "$WORK_DIR/id")" "$KERNEL/vmlinux"
}

cmd_kgdb()
{
    exec "$VMSTART" kgdb "$(cat "$WORK_DIR/id")" "$KERNEL/vmlinux"
}

cmd_mon()
{
    exec "$VMSTART" mon "$(cat "$WORK_DIR/id")"
}

# checks if command is valid
if [ "$(type -t "$CMD")" != "function" ]; then
    usage
    exit 1
fi

eval "$CMD" "$@"
