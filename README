KERNEL VIRTUAL MACHINE TESTING TOOLS:
=====================================

This repository contains some tests for the Linux kernel, and tools to run
them.

A test is contained within a single executable file (typically a bash script)
that will be executed within a VM. Tests declare their dependencies, so that
the ktest tool can run them in the proper environment.

Example test dependencies, from tests/bcache:

if [ "$1" = "deps" ]; then
	echo "REQUIRE=test-libs.sh,make-bcache"
	echo "MEM=512M"
	echo "SCRATCH=512M,2G,2G"
	exit
fi

The full list of possible requirements:

 * MEM (required): amount of memory for the VM

 * SCRATCH: scratch block devices, a comma separated list of sizes. They'll
   be available within the VM as vda/vdb/etc.

 * REQUIRE: comma separated list of files/executables to make available within
   the VM. They'll be available in the same directory as the test script
   (/cdrom), and in PATH. The ktest run command will search for requirements
   first relative to the test, then in your PATH.

 * LREQUIRE: Comma separated list of dependencies to include from the local
   source tree - i.e. executables in the Linux kernel repository under tools/.

The test can indicate success by echoing "TEST SUCCESS" to standard output;
that will cause the vm to be shut down and ktest to return success. If the
test doesn't echo "TEST SUCCESS" the vm will run forever - unless ktest was
run with a timeout, in which case the vm will shut down and ktest will return
failure once the timeout elapses.

TOOLS:
======

 * create_vm_image: Create a root filesystem suitable for running tests inside
   a VM. Uses debootstrap to create a minimal debian installation with the
   appropriate configuration.

 * vm-start: Simple python tool for running multiple kvm instances on a
   machine with scratch devices that will be cleaned up when the vm exits, and
   for allocating/freeing slots for networking - used by the ktest.

 * ktest: Builds a kernel and runs a specific test, using vm-start.


GETTING STARTED:
================

As root, create a root filesystem for the virtual machines and place it in
either /var/lib/ktest/root or $HOME/.ktest/root:

  # mkdir /var/lib/ktest
  # create_vm_image /var/lib/ktest/root

The vm-start tool needs a database initialized for the running vms, so it can
allocate slots for networking and make sure scratch devices get cleaned up.
The database will be world writable, and it lives in /etc/vms. To create it,
as root run:

  # vm-start genips

ktest will use /tmp for the VM scratch devices by default; if you wish to use
another directory you can create a symlink to it at $HOME/.ktest/tmp. I
suggest using a tmpfs.


USING KTEST:
============

From within the kernel source tree you wish to test, run

  $ ktest run <testfile>

ktest will build a kernel (using .ktest for the output directory), launch a vm
and start running your test. Output goes to standard output, CTRL-C will kill
the vm and cleanup all scratch devices and sockets.

ktest has a variety of other useful subcommands:

  * ktest ssh logs in as root to a vm launched by ktest from the current
    directory

  * ktest gdb runs gdb and connects it to kgdb's serial interface

  * ktest mon connects to qemu's monitor interface

These commands will connect to the vm that was run by ktest from the current
directory.

  * ktest oldconfig, ktest config run make oldconfig and make nconfig on the
    kernel configuration in .ktest - but passing the same options to make as
    with ktest run, so as to avoid unnecessary recompiles.

TODO:
  * TEST_REQUIRE - recursively handle dependencies

  * More tests, including integrating other existing tests - i.e. a shim for
    xfstests

  * Network tests - i.e. tests that require multiple VMs

  * ???
