#!/bin/bash
#
# Test wrapper run inside the VM

set -o nounset
set -o errexit
set -o errtrace

echo "mount logfs"
LOGDIR=/var/log/datera
mkdir -p $LOGDIR
mount -t 9p -o trans=virtio logfs /var/log/datera

echo 1 > /proc/sys/fs/suid_dumpable
echo $LOGDIR/core.%e.PID%p.SIG%s.TIME%t > /proc/sys/kernel/core_pattern
ulimit -c unlimited

for i in `cat /proc/cmdline`; do
    case $i in
	ktest.*)
	    export ktest_${i##ktest.}
	    ;;
    esac
done

NR_REBOOTS=$([ -e /NR_REBOOTS ] && cat /NR_REBOOTS || echo 0)

EXPECTED_REBOOT=$([ -e /EXPECTED_REBOOT ] && cat /EXPECTED_REBOOT || echo 0)

echo $((NR_REBOOTS + 1)) > /NR_REBOOTS

if [ $NR_REBOOTS != $EXPECTED_REBOOT ]; then
    echo "UNEXPECTED REBOOT"
    echo "TEST FAILED"
    exit 1
fi

echo "TEST REBOOT $NR_REBOOTS"

copy_to_host()
{
    cat /sys/kernel/debug/tracing/trace >> $LOGDIR/trace.txt

    for file in $(find /sys -type f -perm u+r); do
	echo -n "$file: "; cat $file
    done >> $LOGDIR/sysfs.txt

    # Code coverage
    gcov_dir=/sys/kernel/debug/gcov

    if [ -d $gcov_dir ]; then
	# find a destination dir that doesn't exist, so we can copy multiple
	# sets of gcov data from different tests/reboots and merge them later

	for i in {0..99}; do
	    dst=$LOGDIR/gcov.$i

	    if [ ! -d $dst ]; then
		cp -dR $gcov_dir $dst
		break
	    fi
	done
    fi

    (
        set +e
        fuser -INT -k $LOGDIR $LOGDIR/*
        sync
        sleep 1
        fuser -k $LOGDIR $LOGDIR/*
        umount $LOGDIR
    )
}

do_reboot()
{
    copy_to_host

    echo $((NR_REBOOTS + 1)) | dd of=/EXPECTED_REBOOT oflag=direct
    echo b > /proc/sysrq-trigger
}

require-lib()
{
    . `basename "$1"`
}

require-bin()
{
    return 0
}

require-container()
{
    return 0
}

require-kernel-config()
{
    return 0
}

config-scratch-devs()
{
    return 0
}

config-mem()
{
    return 0
}

config-infiniband()
{
    return 0
}

config-vmcount()
{
    return 0
}

config-timeout()
{
    return 0
}

set +e

(set -e; . rc.test; main)
ret=$?

set -e

# XXX: check dmesg for warnings, oopses, slab corruption, etc. before signaling
# success

copy_to_host

if [ $ret = 0 ]; then
    echo "TEST SUCCESS"
else
    echo "TEST FAILED"
fi

exit 0
