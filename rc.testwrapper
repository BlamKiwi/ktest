#!/bin/bash
#
# Test wrapper run inside the VM

set -o nounset
set -o errexit
set -o errtrace

export PS4='+`basename ${BASH_SOURCE[0]}`:${LINENO}:${FUNCNAME[0]:+${FUNCNAME[0]}()}+ '

KTESTDIR=$(dirname "$(readlink -f "$0")")
. "$KTESTDIR/util.sh"

TEST_RUNNING=1
KERNEL_ARCH=""

dmesg --console-on
dmesg --console-level 8

for i in $(</proc/cmdline); do
    case $i in
	ktest.*)
	    export ktest_${i##ktest.}
	    ;;
    esac
done

echo 1 > /proc/sys/kernel/sysrq
ulimit -c unlimited

# Log file system visible to host

LOGDIR=/ktest-out
mkdir -p $LOGDIR
mount -t 9p -o trans=virtio logfs $LOGDIR

# Core dump settings
echo 1 > /proc/sys/fs/suid_dumpable
echo "|/bin/cp --sparse=always /dev/stdin $LOGDIR/core.%e.PID%p.SIG%s.TIME%t" > /proc/sys/kernel/core_pattern
ulimit -c unlimited
rm -f /ktest-out/core.*

# Virtual block device tweaks
for q in /sys/block/sd*/queue; do
    echo noop > $q/scheduler
done

# Check if we are running the crashdump kernel
if [[ -s /proc/vmcore ]]; then
    echo "Collecting crash dump..."
    rm -f "$LOGDIR/vmcore"
    cp --sparse=always /proc/vmcore "$LOGDIR/vmcore" || true
    sync
    poweroff
fi

# If debugging crash dumps, add "console=hvc0" to the append line
# below:
if [[ $ktest_crashdump = 1 ]]; then
    kexec -p /cdrom/vmlinuz --append="root=/dev/sda rw maxcpus=1" || true
fi

NR_REBOOTS=0
EXPECTED_REBOOT=0
[[ -e /NR_REBOOTS ]]		&& NR_REBOOTS=$(</NR_REBOOTS)
[[ -e /EXPECTED_REBOOT ]]	&& EXPECTED_REBOOT=$(</EXPECTED_REBOOT)

if [[ $NR_REBOOTS != $EXPECTED_REBOOT ]]; then
    echo "UNEXPECTED REBOOT: got $NR_REBOOTS expected $EXPECTED_REBOOT"
    echo "TEST FAILED"
    exit 1
fi

echo $((NR_REBOOTS + 1)) | dd of=/NR_REBOOTS oflag=direct 2> /dev/null

if compgen -G "/cdrom/*.deb" > /dev/null; then
    if ! output=$(dpkg -i /cdrom/*.deb); then
	echo $output
	exit 1
    fi
fi
cd /root

copy_to_host()
{
    cat /sys/kernel/debug/tracing/trace >> $LOGDIR/trace.txt

    # Code coverage
    gcov_dir=/sys/kernel/debug/gcov

    if [[ -d $gcov_dir ]]; then
	# find a destination dir that doesn't exist, so we can copy multiple
	# sets of gcov data from different tests/reboots and merge them later

	for i in {0..99}; do
	    dst=$LOGDIR/gcov.$i

	    if [[ ! -d $dst ]]; then
		cp -dR $gcov_dir $dst
		break
	    fi
	done
    fi

    (
        set +e
        fuser -INT -k $LOGDIR $LOGDIR/*
        sync
        #sleep 1
        #fuser -k $LOGDIR $LOGDIR/*
        #umount $LOGDIR
    )
}

check_taint()
{
    read taint < /proc/sys/kernel/tainted

    if [[ $taint != 0 ]]; then
	echo "Failure because kernel tainted - check log for warnings"
	echo "TEST FAILED"
	exit 0
    fi
}

do_reboot()
{
    copy_to_host
    check_taint

    echo $((NR_REBOOTS + 1)) | dd of=/EXPECTED_REBOOT oflag=direct 2> /dev/null
    echo b > /proc/sysrq-trigger
}

require-lib()
{
    . `basename "$1"`
}

require-bin()
{
    return 0
}

require-build-deb()
{
    return 0
}

require-make()
{
    return 0
}

require-file()
{
    return 0
}

require-kernel-config()
{
    return 0
}

require-kernel-append()
{
    return 0
}

config-scratch-devs()
{
    return 0
}

config-image()
{
    return 0
}

config-cpus()
{
    return 0
}

config-mem()
{
    return 0
}

config-nr-vms()
{
    return 0
}

config-timeout()
{
    return 0
}

. rc.test

if [[ $(type -t list_tests) == function ]]; then
    tests=$(list_tests)
else
    tests=$(declare -F|sed -ne '/ test_/ s/.*test_// p')
fi

# may be overridden by test:
if [[ $(type -t run_test) != function ]]; then
    run_test()
    {
	test_$1
    }
fi

# may be overridden by test:
if [[ $(type -t run_tests) != function ]]; then
    run_tests()
    {
	local tests=$1
	local tests_passed=()
	local tests_failed=()

	echo
	echo "Running tests $tests"
	echo

	for i in $tests; do
	    echo "========= Running test $i"
	    echo

	    set +e
	    (set -e; run_test $i)
	    local ret=$?
	    set -e

	    kill $(list_descendants $$) >/dev/null 2>&1 || true

	    echo
	    echo "========= Test $i completed with ret $ret"

	    # XXX: check dmesg for warnings, oopses, slab corruption, etc. before
	    # signaling success

	    if [[ $ret = 0 ]]; then
		tests_passed+=($i)
	    else
		tests_failed+=($i)
	    fi

	    [[ $ret != 0 && $ktest_failfast = 1 ]] && break

	    for dev in /dev/sd*; do
		[[ $dev = /dev/sda ]] && continue
		umount $dev >/dev/null 2>&1 || true
	    done
	done

	echo
	echo "Passed: ${tests_passed[@]}"
	echo "Failed: ${tests_failed[@]}"

	[[ ${#tests_failed[@]} != 0 ]] && return 1
    }
fi

if [[ -z $tests ]]; then
    echo "No tests found"
    exit 1
fi

testargs=$(</cdrom/testargs)
[[ -n $testargs ]] && tests="$testargs"

tests=$(echo $tests)

if [[ -n ${ktest_timeout+x} ]]; then
    (
	sleep $ktest_timeout
	echo "TEST TIMEOUT - triggering crash"
	echo c > /proc/sysrq-trigger
    ) &
fi

ret=0
while [[ $ret = 0 ]]; do
    run_tests $tests || ret=1
    [[ $ktest_loop = 1 ]] || break
done

copy_to_host
check_taint

if [[ $ret = 0 ]]; then
    echo "TEST SUCCESS"
else
    echo "TEST FAILED"
fi

exit 0
