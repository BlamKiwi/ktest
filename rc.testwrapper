#!/bin/bash
#
# Test wrapper run inside the VM

set -o nounset
set -o errexit
set -o errtrace

export PS4='+`basename ${BASH_SOURCE[0]}`:${LINENO}:${FUNCNAME[0]:+${FUNCNAME[0]}()}+ '

TEST_RUNNING=1

. /cdrom/rc.interactive

for i in `cat /proc/cmdline`; do
    case $i in
	ktest.*)
	    export ktest_${i##ktest.}
	    ;;
    esac
done

copy_to_host()
{
    cat /sys/kernel/debug/tracing/trace >> $LOGDIR/trace.txt

    # Code coverage
    gcov_dir=/sys/kernel/debug/gcov

    if [ -d $gcov_dir ]; then
	# find a destination dir that doesn't exist, so we can copy multiple
	# sets of gcov data from different tests/reboots and merge them later

	for i in {0..99}; do
	    dst=$LOGDIR/gcov.$i

	    if [ ! -d $dst ]; then
		cp -dR $gcov_dir $dst
		break
	    fi
	done
    fi

    (
        set +e
        fuser -INT -k $LOGDIR $LOGDIR/*
        sync
        sleep 1
        fuser -k $LOGDIR $LOGDIR/*
        umount $LOGDIR
    )
}

check_taint()
{
    read taint < /proc/sys/kernel/tainted

    if [[ $taint != 0 ]]; then
	echo "Failure because kernel tainted - check log for warnings"
	echo "TEST FAILED"
    fi
}

do_reboot()
{
    copy_to_host
    check_taint

    echo $((NR_REBOOTS + 1)) | dd of=/EXPECTED_REBOOT oflag=direct 2> /dev/null
    echo b > /proc/sysrq-trigger
}

require-lib()
{
    . `basename "$1"`
}

require-bin()
{
    return 0
}

require-make()
{
    return 0
}

require-file()
{
    return 0
}

require-kernel-config()
{
    return 0
}

config-scratch-devs()
{
    return 0
}

config-cpus()
{
    return 0
}

config-mem()
{
    return 0
}

IB_MOD_DIRS="infiniband/core infiniband/hw/mlx4 infiniband/ulp/ipoib"

config-infiniband()
{
    modprobe -v mlx4_core
    
    local driver_dir="/lib/modules/`uname -r`/kernel/drivers"

    for mdir in $IB_MOD_DIRS ; do
        local dir="$driver_dir/$mdir"
        cd $dir
        for file in * ; do
            local mod_name=${file%%.*}
            modprobe -v "$mod_name"
        done
    done

    sleep 1
    cd /cdrom
}

config-nr-vms()
{
    return 0
}

config-timeout()
{
    return 0
}

NR_REBOOTS=$([ -e /NR_REBOOTS ] && cat /NR_REBOOTS || echo 0)

EXPECTED_REBOOT=$([ -e /EXPECTED_REBOOT ] && cat /EXPECTED_REBOOT || echo 0)

if [ "$NR_REBOOTS" != "$EXPECTED_REBOOT" ]; then
    echo "UNEXPECTED REBOOT: got $NR_REBOOTS expected $EXPECTED_REBOOT"
    echo "TEST FAILED"
    exit 1
fi

(
    sleep $ktest_timeout
    echo "TEST TIMEOUT - triggering crash"
    echo c > /proc/sysrq-trigger
) &

echo "Test starting: NR_REBOOTS $NR_REBOOTS"
echo $((NR_REBOOTS + 1)) | dd of=/NR_REBOOTS oflag=direct 2> /dev/null

set +e

(set -e; . rc.test; main)
ret=$?

echo "Test finished with ret $ret"
echo "Copying output to host"

# XXX: check dmesg for warnings, oopses, slab corruption, etc. before signaling
# success

copy_to_host
check_taint

if [ $ret = 0 ]; then
    echo "TEST SUCCESS"
else
    echo "TEST FAILED"
fi

exit 0
