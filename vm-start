#!/usr/bin/python
# Copyright (c) 2013 Datera, Inc. All rights reserved
# Datera, Inc. Confidential and Propriatory

import sys
import os
import fcntl
import subprocess
import shelve
import operator
import time
import string
import random
import re

from optparse import OptionParser, OptionGroup

# script directory and path
DIR=os.path.dirname(__file__)       # path to script directory

# global info file settings:
IP_FILE = "/etc/vms/ips"
PCI_CONNECTX3_FILE = "/etc/vms/pci_connectx3"
IP_FILE_LOCK = IP_FILE+".lock"      # File we use to lock access to VM info list or dict
IP_FILE_DICT = IP_FILE+".dict"      # Shelf file used to store vm information as python objects

PCI_CONNECTX3_FILE_LOCK = PCI_CONNECTX3_FILE+".lock"
				    # File we use to lock access to VM info list or dict
PCI_CONNECTX3_FILE_DICT = PCI_CONNECTX3_FILE+".dict"
				    # Shelf file used to store vm information as python objects

MAX_VMS = 100                       # Max number of VMs. Currently this is pretty arbitrary.

DEFAULT_MEMORY = "1G"               # how much memory to give the vms
DEFAULT_TMP = "/tmp"                # default directory for tmps
DEFAULT_TIMEOUT = 10*60             # timeout: 10 mins

USER_NETWORKING = True

# colors:
GREEN='\033[32m'
CYAN='\033[36m'
NC='\033[0m'

DEVNULL = open(os.devnull, "wb")


"""
Functions of opening shelf to lock while
reading and writing to shelf file
"""
def openLockedDb(file_lock, file_dict):
    lockFD = os.open(file_lock, os.O_RDONLY)
    fcntl.flock(lockFD, fcntl.LOCK_EX)
    db = shelve.open(file_dict)
    db.lockFD = lockFD
    return db

def closeLockedDb(db):
    db.close()
    fcntl.flock(db.lockFD, fcntl.LOCK_UN)
    os.close(db.lockFD)

"""
Print Error:
"""
def die(msg, exitStatus=1):
    print >> sys.stderr, "vm-script error: "+msg
    sys.exit(exitStatus)

def warning(msg):
    print >> sys.stderr, "vm script warning: "+msg

class Domain:
    """Represents a single virtual machine"""
    def __init__ (self, vm_id, ip, mac):
	self.vm_id = vm_id         # id number for this vm
	self.ip = ip               # ip address
	self.mac = mac             # mac addresss
	self.owner = None          # who started this machine
	self.pid = None            # qemu process ID
	self.name = "vm"+str(vm_id)   # name of the vm, can be custom
	self.base = None           # base image if this isn't persistant
	self.kernel = None         # kernel image booted with
	self.tmpdir  = None        # the location of dir to store scratch drives
	self.conx3_id = None 	 # dev id of the virtual pci x3 Connect X3 card
    
    def exists(self):
	"""Does the VM this represents actually exists?"""
	if subprocess.call("ps aux | grep "+str(self.tmpdir)+" | grep "+str(self.pid)+
		    " | grep -v grep", shell=True, stdout=DEVNULL):
	    return False
	return True
    
    def kill(self):
	"""This kills the VM"""
	if not self.pid:
	    print "Vm "+self.name+"never started. Releasing domain"
	    return True

	if not self.exists():
	    print "Vm "+self.name+" terminated. Releasing domain"
	    return True

	if subprocess.call("kill "+str(self.pid), shell=True):
	    print "Error killing vm: "+self.name
	    return False
	
	print "Vm "+self.name+" terminated. Releasing domain"
	return True

def randStr(size=12, chars=string.letters + string.digits):
    return "".join(random.choice(chars) for x in range(size))

def cmd_start():
    """Start new virtual machines"""

    opt=OptionParser("usage: %prog vm start [number]",
		     description="""Boot start virtual machines""")
    opt.add_option("-i", "--image", dest="image",
		   help="boot image of the virtual machine")
    opt.add_option("-k", "--kernel", dest="kernel",
		   help="kernel qemu should use to boot")
    opt.add_option("-r", "--initrd", dest="initrd",
		   help="initial ramdisk for boot")
    opt.add_option("-a", "--append", dest="append",
		   help="append kernel boot arguments",
		   default="root=/dev/sda rw")
    opt.add_option("-c", "--cdrom-source", dest="cdrom",
		   help="source to made into a cdrom")
    opt.add_option("-s", "--scratch-dev ", dest="scratch",
		   help="list of scratch device sizes. ex: 256M,2G")
    opt.add_option("-t", "--tmpfs-dir", dest="tmpfs", default=DEFAULT_TMP,
		   help="location of the tmpfs directory. Only used for scratch devs")
    opt.add_option("-m", "--memory", dest="mem", default=DEFAULT_MEMORY,
		   help="amount of memory to be allocated per VM")
    opt.add_option("--cpus", dest="cpus", default="1",
		   help="number of CPUs allocated.")
    opt.add_option("-p", "--persistant", dest="persistant", action="store_true",
		   help="turns off snapshot, so writeback happens to disk instead of tmp")
    opt.add_option("--fs", dest="filesystems", action="append", nargs=2,
		   help="mount a directory (first argument) as a filesystem label (second argument) in the VM")
    opt.add_option("--id", dest="indexfile", help="file to write vm number to")
    opt.add_option("--conx3", action="store_true", dest="assign_conx3", default=False,
		   help="assign a virtual pci connect x3 nic for rdma")
    opt.add_option("--vde", dest="vde", action="store_true", 
		   help="use vde networking instead of user mode. This requires a vde"+
		   "switch to be set up, and an dns setup to listen")
    (options, args) = opt.parse_args()
    
    if not options.image:
	die ("Requires an image to boot")
    if not os.path.isfile(options.image):
	die("Cannot find base image file: "+options.image)
    #if not options.kernel:
    #   die("Requires a kernel to boot")
    if options.kernel and not os.path.isfile(options.kernel):
	die("Cannot find kernel file: "+options.kernel)
    if options.initrd and not os.path.isfile(options.initrd):
	die("Cannot find initrd file: "+options.initrd)

    # get user if SUDO
    try:
	user = os.environ["SUDO_USER"]
    except KeyError:
	user = os.environ["USER"]
    
    #load database:
    d = openLockedDb(IP_FILE_LOCK, IP_FILE_DICT)
    free_vms = d["free_vms"]
    
    # check to make sure we have enough domains
    if len(free_vms) == 0:
	d.close()
	dropLock(lock)
	die("Not enough domains to start a vms")
    
    # get domain, mark for setup
    vm = free_vms.pop()
    vm.state = "setup"
    vm.owner = user
    
    # save and free up database while launching vms
    d["free_vms"] = free_vms
    closeLockedDb(d)
    
    try:
	# generate tmp dir
	vm.tmpdir = options.tmpfs+"/"+randStr()+"-vm"+str(vm.vm_id)+"-"+user
	try:
	    os.mkdir(vm.tmpdir, 0700)
	except OSError:
	    die ("Failed to create tmpdir: "+vm.tmpdir)
        vm.tmpdir += "/"

	# setup run CD:
	if not options.cdrom:
	    iso=None
	elif os.path.isdir(options.cdrom):
	    iso = vm.tmpdir + "run.iso"
	    if subprocess.call(["genisoimage", "-quiet", "-R", "-input-charset",
			 "utf-8", "-o", iso, options.cdrom]):
		die("Could not create cdrom from dir: "+options.cdrom)
	else:
	    iso=options.cdrom

	# generates scratch drives:
	drives = []
	if options.scratch:
	    sizes = options.scratch.split(",")
	    i = 1;
	for size in sizes:
	    name = str(vm.tmpdir)+"disk-"+str(i)
	    i += 1
	    if subprocess.call(["fallocate", "-l", size, name]):
		warning ("Error creating a "+size+" scratch drive with fallocate. Trying dd")
		if subprocess.call(["dd", "if=/dev/zero", "of="+name, "count=1", "bs="+size]):
		    die ("Error creating a "+size+" scratch drive with dd")
            drives.append(name)

	if options.indexfile:
	    f=open(options.indexfile, "w")
	    f.write(str(vm.vm_id))
	    f.close()

	# build qemu command and start
	cmd = ["qemu-system-x86_64"]
	cmd.extend(["-machine", "accel=kvm"])
	cmd.extend(["-pidfile", vm.tmpdir + "pid"])
	cmd.extend(["-m", options.mem])
	# LAPIC bug in qemu, shows up occasionally as a kernel panic.
	# Use threads= for smp.
	cmd.extend(["-smp", "1,cores=1,threads=" + options.cpus])
	#cmd.extend(["-vnc", "0.0.0.0:"+str(17100+vm.vm_id)])
	if options.kernel:
	    cmd.extend(["-kernel", options.kernel])
	    kernelParams = "console=ttyS0,115200 kgdboc=ttyS2,115200"
	    if options.vde:
		kernelParams += " ip="+vm.ip
	    if options.append:
		kernelParams += " "+options.append
	    cmd.extend(["-append", kernelParams])
	if options.initrd:
	    cmd.extend(["-initrd", options.initrd])
	cmd.extend(["-nographic"])
	cmd.extend(["-serial",	"stdio"])
	cmd.extend(["-serial",	"mon:unix:" + vm.tmpdir + "con,server,nowait"])
	cmd.extend(["-serial",	"unix:" + vm.tmpdir + "kgdb,server,nowait"])
	cmd.extend(["-monitor",	"unix:" + vm.tmpdir + "mon,server,nowait"])
	cmd.extend(["-gdb",	"unix:" + vm.tmpdir + "gdb,server,nowait"])

	# Devices:
	if options.persistant:
	    cmd.extend(["-drive", "format=raw,file="+options.image])
	else:
	    cmd.extend(["-drive", "format=raw,snapshot=on,file="+options.image])
	if options.filesystems:
	    for fspath, fslabel in options.filesystems:
		cmd.extend(["-virtfs", "local,path="+fspath+",mount_tag="+fslabel+",security_model=none,readonly"])
	for drive in drives:  # add scratch drives
	    cmd.extend(["-drive", "if=virtio,format=raw,cache=writeback,file="+drive])
	if iso:              # add cdrom
	    cmd.extend(["-cdrom", iso])
	if options.vde:   # enable vde networking
	    cmd.extend(["-netdev", "vde,id=vde_net,sock=/tmp/vde.ctl"])
	    cmd.extend(["-device", "virtio-net-pci,netdev=vde_net,mac="+vm.mac])
	    vm.vde = True
	else:             # user networking instead
	    cmd.extend(["-net", "nic,model=virtio"])
	    cmd.extend(["-net", "user,host=10.0.2.2,restrict=off,hostfwd=tcp:127.0.0.1:" + str(vm.vm_id + 9000) + "-:22"])
	    vm.vde = False

	if options.assign_conx3:
	    db = openLockedDb(PCI_CONNECTX3_FILE_LOCK, PCI_CONNECTX3_FILE_DICT)
	    free_conx3 = db["free_conx3"]
	    if len(free_conx3) == 0:
		closeLockedDb(db)
		die("Not enough virtual connect x3 to start a vms")
	    vm.conx3_id = free_conx3.pop()
	    cmd.extend(["-device", "pci-assign,host="+str(vm.conx3_id)])
	    print "Assigning vf: ", vm.conx3_id
	    # save and free up database while using a card
	    db["free_conx3"] = free_conx3
	    closeLockedDb(db)
	else:
	    vm.conx3_id = None

	p = subprocess.Popen(cmd, shell=False)

	vm.pid = p.pid
	vm.status="running"
	print GREEN+"Vm ID: "+str(vm.vm_id)+" IP: "+vm.ip+" MAC: "+vm.mac+NC
    
    except Exception as e:
	# so we don't lose vm if exception occurs. Prolly could be better made
	d = openLockedDb(IP_FILE_LOCK, IP_FILE_DICT)
	free_vms = d["free_vms"]
	free_vms.append(vm)
	d["free_vms"] = sorted(free_vms, key=operator.attrgetter("vm_id"), reverse=True)
	closeLockedDb(d)

	if vm.conx3_id is not None:
	    db = openLockedDb(PCI_CONNECTX3_FILE_LOCK, PCI_CONNECTX3_FILE_DICT)
	    free_conx3 = db["free_conx3"]
	    free_conx3.append(vm.conx3_id)
	    db["free_conx3"] = free_conx3
	    closeLockedDb(db)

	exc_type, exc_obj, exc_tb = sys.exc_info()
	fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
	die("Unexpected Exception: "+str(exc_type)+", File: "+str(fname)+", Line: "+str(exc_tb.tb_lineno))
    
    # resave vms with process and pid information
    d = openLockedDb(IP_FILE_LOCK, IP_FILE_DICT)
    running_vms=d["running_vms"]
    running_vms.append(vm)
    d["running_vms"] = running_vms
    closeLockedDb(d)
    
    try:
	print GREEN+"waiting..................."
	p.wait()
    except KeyboardInterrupt:
	warning("KeyBoard interrupt raised")
     
    __stop(vm.vm_id)

def cmd_ssh():
    """ssh into a virtual machine"""
     
    if len(sys.argv)<=1:
	die("Please provide a vm id to SSH to")
    id=int(sys.argv[1])
    
    d = openLockedDb(IP_FILE_LOCK, IP_FILE_DICT)
    running_vms=d["running_vms"]
    vm = next((vm for vm in running_vms if vm.vm_id == id), None)
    closeLockedDb(d)
    
    if vm == None:
	die("No vm running with id: "+str(id))
    
    keyfile=os.path.dirname(os.path.realpath(__file__)) + "/id_dsa"
     
    os.system("chmod 600 " + keyfile)
     
    if vm.vde:
	cmd = ["ssh", "-o", "StrictHostKeyChecking=no", "-o",
	    "UserKnownHostsFile=/dev/null", "-i", keyfile, "root@"+vm.ip]
    else:
	cmd = ["ssh", "-o", "NoHostAuthenticationForLocalhost=yes",
	    "-i", keyfile, "-p", str(9000 + id), "root@127.0.0.1"]
    
    cmd.extend(sys.argv[2:])
    os.execvp("ssh", cmd)

def cmd_stop():
    """Stop virtual machines"""
    
    opt=OptionParser("usage: %prog vm stop [id]",
		     description="""Stop virtual machines""")
    (options, args) = opt.parse_args()
     
    if len(args)==0:
	die("Please provide a vm id to stop")
    
    __stop(int(args[0]))

def cmd_gdb():
    if len(sys.argv)<=2:
	die("Please provide a session ID to SSH to and a vmlinux file")
        
    id=int(sys.argv[1])
    
    d = openLockedDb(IP_FILE_LOCK, IP_FILE_DICT)
    running_vms = d["running_vms"]
    vm = next((vm for vm in running_vms if vm.vm_id == id), None)
    
    # make sure we actually found some
    if not vm:
	closeLockedDb(d)
	die("vm " + str(id) + " not running")
    
    tmpdir = vm.tmpdir
    closeLockedDb(d)
    
    os.execlp("gdb", "gdb",
	      "-ex", "set remote interrupt-on-connect",
	      "-ex", "target remote | socat UNIX-CONNECT:" + tmpdir + "/gdb -",
	      sys.argv[2])

def cmd_kgdb():
    if len(sys.argv)<=2:
	die("Please provide a session ID to SSH to and a vmlinux file")
        
    id=int(sys.argv[1])
    
    d = openLockedDb(IP_FILE_LOCK, IP_FILE_DICT)
    running_vms = d["running_vms"]
    vm = next((vm for vm in running_vms if vm.vm_id == id), None)
    
    # make sure we actually found some
    if not vm:
	closeLockedDb(d)
	die("vm " + str(id) + " not running")
    
    tmpdir = vm.tmpdir
    closeLockedDb(d)
    
    os.execlp("gdb", "gdb",
	      "-ex", "set remote interrupt-on-connect",
	      "-ex", "target remote | socat UNIX-CONNECT:" + tmpdir + "/kgdb -",
	      sys.argv[2])

def cmd_mon():
    if len(sys.argv)<=1:
	die("Please provide a session ID")
    
    id=int(sys.argv[1])
    
    d = openLockedDb(IP_FILE_LOCK, IP_FILE_DICT)
    running_vms = d["running_vms"]
    vm = next((vm for vm in running_vms if vm.vm_id == id), None)
    
    # make sure we actually found some
    if not vm:
	closeLockedDb(d)
	die("vm " + str(id) + " not running")
    
    tmpdir = vm.tmpdir
    closeLockedDb(d)
    
    os.execlp("minicom", "minicom",
	      "-D", "unix#" + tmpdir + "/mon")

def __stop(stop_id):
    """get vm to stop"""
    d = openLockedDb(IP_FILE_LOCK, IP_FILE_DICT)
    running_vms = d["running_vms"]
    vm = next((vm for vm in running_vms if vm.vm_id == stop_id), None)
    
    # make sure we actually found some
    if not vm:
	closeLockedDb(d)
	die("No Running vms with id "+str(stop_id))
    
    # check if they exist and kill if needed
    print "Stopping vm "+str(vm.vm_id)
    
    # kill the vm:
    if not vm.kill():
	# if it can't killed? what now?
	if vm.exists():
	    closeLockedDb(d)
	    die("Couldn't kill: "+vm.name)
    
    if vm.tmpdir:
	os.system("rm -rf " + vm.tmpdir);
    
    vm.state = "stopped"
    vm.owner = None
    vm.pid = None
    vm.name = "vm"+str(vm.vm_id)
    vm.base = None
    vm.kernel = None
    vm.tmpdir = None
    vm.vde = None
    
    if vm.conx3_id is not None:
	db = openLockedDb(PCI_CONNECTX3_FILE_LOCK, PCI_CONNECTX3_FILE_DICT)
	free_conx3 = db["free_conx3"]
	free_conx3.append(vm.conx3_id)
	db["free_conx3"] = free_conx3
	closeLockedDb(db)
    
    # save changes
    running_vms.remove(vm)
    free_vms = d["free_vms"]
    free_vms.append(vm)
    d["free_vms"] =  sorted(free_vms, key=operator.attrgetter("vm_id"), reverse=True)
    d["running_vms"]=running_vms
    closeLockedDb(d)

def cmd_list():
    """List out running VMs"""
    opt=OptionParser("usage: %prog vm list [session_id]",
		     description="""List out running VMs""")
    (options, args) = opt.parse_args()
       
    # get running vms:
    d = openLockedDb(IP_FILE_LOCK, IP_FILE_DICT)
    running_vms = d["running_vms"]
    closeLockedDb(d)
    
    running_vms = sorted(running_vms, key=operator.attrgetter("owner", "vm_id"))
    
    print "Domain\tIP\t\tConX3 id\tOwner\tPID\tDead\tSPECIAL"
    print "------\t------------\t-------\t-----\t-----\t----\t-------"
    
    for vm in running_vms:
	mia=" " if vm.exists() == True else "X"
	line=(str(vm.name)+"\t"+str(vm.ip)+"\t"+str(vm.conx3_id)+"\t"+
	    str(vm.owner)+"\t"+str(vm.pid)+"\t"+mia+"\t")
	print line

def cmd_genips():
    """
    Generates a new set of new IP Macaddress combinations for
    and puts them in the proper locations:
    Vm.ips-dict - shelve dictionary used by python
    Vm.dhcp - contains dhcp entries for dhcpd
    
    For use when setting up networking on a new machine, or if
    any of the config files get screwed up.
    """
    
    opt=OptionParser("usage: %prog vm genips",
		     description="""Generate a new IP/MAC file""")
    (options, args) = opt.parse_args()
    
    if os.geteuid() != 0:
	die("You need root permissions to do this, laterz!")
    
    check = raw_input("This will overwrite any current vm list files. Are you sure? (y): ")
    if check != "y":
	sys.exit(0)
    
    # make directory
    if not os.path.isdir("/etc/vms"):
      try:
         os.mkdir("/etc/vms")
      except OSError:
         die("Failed to create /etc/vms")
    
    # generate database files:
    name = "ips"
    dhcp = open("/etc/vms/Vm.dhcp", "w")
    
    d = shelve.open(IP_FILE_DICT)
    d["sess_id"] = 1000
    free_vms = []
    lock = open(IP_FILE_LOCK, "w")
    lock.write("used for locking access to vm database file")
    
    for i in range (0, 100):
	#generate IP file
	vm_num = str(i).zfill(2)
	name = "vm"+vm_num
	ip = "172.20.0."+str(i+100)
	mac = "DE:AD:BE:EF:01:"+vm_num
	
	#generate DHCP entries
	dhcp.write("\thost "+name+" {\n")
	dhcp.write("\t\thardware ethernet "+mac+";\n")
	dhcp.write("\t\tfixed-address "+ip+";\n")
	dhcp.write("\t}\n\n")
	
	#generate ips dict
	vm = Domain(i, ip, mac)
	free_vms.insert(0, vm)
    
    dhcp.close()
    d["free_vms"] = free_vms
    d["running_vms"] = []
    d.close()
    lock.close()
     
    os.chmod(IP_FILE_DICT, 0666)
    os.chmod(IP_FILE_LOCK, 0666)
    
    print "Setup completed"

def cmd_genconx3():
    """
    Generates a new set of detached virtual Mellanox X3 card
    provided the machine has one. Updates the existing database.
    Your vm can use rdma functionality with this card.
    """

    p = subprocess.Popen(['lspci', '-vvv'], bufsize=-1, stdout=subprocess.PIPE)
    flag = 0
    phys_dev = ""
    for line in p.stdout:
	if flag == 0:
	    if re.search("Mellanox", line):
		entries = re.split('\W+', line)
		searchStr = entries[0] + ':0'
		phys_dev = entries[0] + ':' + entries[1] + '.' + entries[2]
		print phys_dev
		flag = 1
	if flag == 1:
	    if re.search("Number of VFs:", line):
		entries = re.split(',', line)
		entry = re.split(':', entries[0])
		num_vfs='num_vfs=' + str(int(entry[1]))
		entry = re.split(':', entries[1])
		probe_vf='probe_vf=' + str(int(entry[1]))
		entry = re.split(':', entries[2])
		# Number of VFs: 0
		if int(entry[1]) == 0:
		    print "SR-IOV is not yet enabled!"
		    subprocess.call(['rmmod', 'mlx4_ib', 'mlx4_core'])
		    print num_vfs + ' ' + probe_vf
		    subprocess.call(['modprobe', '-v', 'mlx4_core', num_vfs, probe_vf])
		else:
		    print "SR-IOV enabled!"
		break
    p.kill()
    p.wait()

    if flag == 1:
	d = shelve.open(PCI_CONNECTX3_FILE_DICT)
	free_conx3 = []
	lock = open(PCI_CONNECTX3_FILE_LOCK, "w")
	lock.write("used for locking access to pci connect x3 nic database file")
	# when flag is 1, we know that our machine does have a mellanox X3 card
	# Now detach the pci cards and keep populate db
	subprocess.call(['modprobe', '-v', 'pci_stub'])
	subprocess.call(['modprobe', '-v', 'mlx4_core'])
	# The following are to get the ib0 up on the host
	# Similar calls need to made on the guest to get
	# the guest ib0 up too.
	subprocess.call(['modprobe', '-v', 'ib_addr'])
	subprocess.call(['modprobe', '-v', 'ib_cm'])
	subprocess.call(['modprobe', '-v', 'ib_core'])
	subprocess.call(['modprobe', '-v', 'ib_mad'])
	subprocess.call(['modprobe', '-v', 'ib_umad'])
	subprocess.call(['modprobe', '-v', 'ib_sa'])
	subprocess.call(['modprobe', '-v', 'ib_uverbs'])
	subprocess.call(['modprobe', '-v', 'ib_ipoib'])
	p = subprocess.Popen(['lspci', '-n'], bufsize=-1, stdout=subprocess.PIPE)
	flag = 0
	for line in p.stdout:
	    m = re.match(searchStr, line)
	    if m:
		entries = re.split(' ', line)
		#entries[0] is the vf id
		#entries[2] is the vendor and the device id
		if not re.match(phys_dev, entries[0]):
		    if flag == 0:
			entry = re.split('[:\n]', entries[2])
			vend_dev_id = entry[0] + ' ' + entry[1]
			f = open('/sys/bus/pci/drivers/pci-stub/new_id', 'w')
			f.write(vend_dev_id)
			f.close()
			flag = 1
		    fn = '/sys/bus/pci/devices/0000:' + entries[0] + '/driver/unbind'
		    devid = '0000:' + entries[0]
		    f = open(fn, 'w')
		    f.write(devid)
		    f.close()
		    f = open('/sys/bus/pci/drivers/pci-stub/bind', 'w')
		    f.write(devid)
		    f.close()
		    # populate the connect x3 pci cards db with these devids
		    free_conx3.append(entries[0])
		    d["free_conx3"] = free_conx3
		    print d["free_conx3"]
	d["free_conx3"] = free_conx3
	d.close()
	lock.close()
	p.kill()
	p.wait()

def cmd_help():
    print """List of valid commands:
	start    starts a vm
	stop     stop a vm by name
	list     list all running vms
	genips   generate a fresh vm database
	genconx3  update db with virtual rdma capable nic
	"""

# main:
if len(sys.argv) == 1:
    cmd_help()
    die("Please give a command")

if sys.argv[1] == "-h":
    cmd_help()
    sys.exit(0)

# try looking up given command in global namespace:
try:
    func = "cmd_"+sys.argv[1]
    func = getattr(sys.modules[__name__], func)
except AttributeError:
    cmd_help()
    die(sys.argv[1]+" is not a valid command")

# check for vm.dict setup:
if func != cmd_genips:
    if not os.path.isfile(IP_FILE_DICT):
	die("Vm list file not found. Please run genips")
    if not os.path.isfile(IP_FILE_LOCK):
	die("Lock file for vm list access not found. Did you run genips?")

sys.argv.pop(1)
func()
