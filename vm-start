#!/usr/bin/python
# Copyright (c) 2013 Datera, Inc. All rights reserved
# Datera, Inc. Confidential and Propriatory

import getpass
import sys
import os
import errno
import fcntl
import subprocess
import shelve
import shutil
import signal
import operator
import time
import string
import random
import re
import datetime
import logging
import traceback
import atexit

from contextlib import contextmanager

from optparse import OptionParser, OptionGroup

# script directory and path
DIR=os.path.dirname(__file__)       # path to script directory

MAX_VMS = 100                       # Max number of VMs. Currently this is pretty arbitrary.
MAX_BRIDGES = 256
MIN_BRIDGE = 101

# global info file settings:
IP_FILE = "/etc/vms/ips"
IP_FILE_LOCK = IP_FILE+".lock"      # File to lock access to VM list
IP_FILE_DICT = IP_FILE+".dict"      # Shelf file to store vm list

# Locate available ConnectX-3 virtual interfaces
CX3_PCI_STUB_DIR="/sys/bus/pci/drivers/pci-stub"
CX3_VENDOR_IDS = [ 0x15b3 ]
CX3_DEVICE_IDS = [ 0x1004 ]

DEFAULT_MEMORY = "1G"               # how much memory to give the vms
DEFAULT_TMP = "/tmp"                # default directory for tmps
DEFAULT_TIMEOUT = 10*60             # timeout: 10 mins

# colors:
GREEN='\033[32m'
CYAN='\033[36m'
NC='\033[0m'

FNULL=open(os.devnull, 'rw')

def randstr(size=8, chars=string.letters + string.digits):
    return "".join(random.choice(chars) for x in range(size))

def readfile(filename):
    with open(filename, 'r') as f:
        line = f.readline()
    return line

def writefile(filename, line):
    logging.debug("in writefile - writing <%s> into %s" % (line,filename))
    with open(filename, 'w') as f:
        f.write(str(line)+"\n")

def appendfile(filename, line):
    newline = ""
    if os.path.exists(filename):
        with open(filename, 'r') as f:
            newline = f.read()
            newline = newline.strip()
            newline += "/"
                   
    newline += str(line)
    logging.debug("in appendfile - writing <%s> into %s" % (newline,filename))
    with open(filename, 'w') as f:
        f.write(newline+"\n")  

"""
Functions of opening shelf to lock while
reading and writing to shelf file
"""
def openLockedDb(file_lock, file_dict):
    lockFD = os.open(file_lock, os.O_RDONLY)
    fcntl.flock(lockFD, fcntl.LOCK_EX)
    db = shelve.open(file_dict)
    db.lockFD = lockFD
    return db

def closeLockedDb(db):
    db.close()
    fcntl.flock(db.lockFD, fcntl.LOCK_UN)
    os.close(db.lockFD)

class Domain:
    """Represents a single virtual machine"""
    def __init__ (self, vm_id):
        self.vm_id = vm_id         # id number for this vm
        self.ip = None               # ip address
        self.mac = None             # mac addresss
        self.owner = None          # who started this machine
        self.pid = None            # PID of the running qemu process
        self.name = "vm"+str(vm_id)   # name of the vm, can be custom
        self.tmpdir  = None        # the location of dir to store scratch drives
        self.conx3_id = None       # dev id of the virtual pci x3 Connect X3 card

    def __getattr__(self, name):
        """Fixup old versions of this clas saved in the DB"""
        if name in ("ip", "mac", "owner", "pid", "tmpdir", "conx3_id"):
            return None
        else:
            raise AttributeError("%s instance has no attribute '%s'" % (self.__class__.__name__, name))

    def exists(self):
        """Does the VM this represents actually exist?"""
        try:
            if self.pid is not None:
                expath = os.path.basename(os.readlink("/proc/%d/exe" % self.pid))
                if expath[:11] == "qemu-system":
                    return True
        except (OSError, IOError, ValueError) as e:
            pass

        return False

@contextmanager
def vm_slot_update(id):
    d = openLockedDb(IP_FILE_LOCK, IP_FILE_DICT)
    running_vms = d["running_vms"]
    vm = next((vm for vm in running_vms if vm.vm_id == id), None)
    try:
        yield vm
        d["running_vms"] = running_vms
    finally:
        closeLockedDb(d)

def vm_slot_put(id):
    d = openLockedDb(IP_FILE_LOCK, IP_FILE_DICT)
    running_vms = d["running_vms"]
    vm = next((vm for vm in running_vms if vm.vm_id == id), None)

    if not vm:
        closeLockedDb(d)
        return

    running_vms.remove(vm)
    d["running_vms"] = running_vms

    closeLockedDb(d)

def vm_slot_get(tmpdir, ip, conx3):
    try:
        user = os.environ["SUDO_USER"]
    except KeyError:
        user = os.environ["USER"]

    #load database:
    d = openLockedDb(IP_FILE_LOCK, IP_FILE_DICT)
    running_vms=d["running_vms"]

    # check to make sure we have a free vm entry
    free_vmids=range(MAX_VMS)
    for vm in running_vms:
        try:
            free_vmids.remove(vm.vm_id)
        except ValueError:
            pass

    if len(free_vmids) == 0:
        closeLockedDb(d)
        raise RuntimeError("No vm entries available to start a vm")

    if conx3:
        cards = list_conx3()
        logging.debug("CX3 cards detected: %s" % ' '.join(cards))
        for vm in running_vms:
            if vm.conx3_id in cards:
                cards.remove(vm.conx3_id)
        if len(cards) == 0:
            raise RuntimeError("ConnectX3 was requested but none available")
        logging.debug("Assigning CX3 card %s" % cards[0])
        conx3_id = cards[0]
    else:
        conx3_id = None


    # get vm entr, mark for setup
    vm = Domain(free_vmids[0])
    vm.state    = "setup"
    vm.owner    = user
    vm.tmpdir   = tmpdir
    vm.conx3_id = conx3_id
    vm.ip       = ip

    running_vms.append(vm)
    d["running_vms"] = running_vms

    closeLockedDb(d)
    return vm

def vm_lookup(id):
    d = openLockedDb(IP_FILE_LOCK, IP_FILE_DICT)
    running_vms = d["running_vms"]
    vm = next((vm for vm in running_vms if vm.vm_id == id), None)
    closeLockedDb(d)

    # make sure we actually found some
    if not vm:
        raise RuntimeError("vm " + str(id) + " not running")

    return vm


def vm_cleanup(vmdir):

    idfile = os.path.join(vmdir,"id")
    pidfile = os.path.join(vmdir,"pid")
        
    ids = ""
    try:
        with open(idfile,"r") as f:
            ids = f.read()
    except:
        pass
    
    ids = ids.split("/")
    
    if ids[0] == "":
        raise RuntimeError("No ids found in <%s>!" % idfile)
    
    pid = "NONE"
    try:
        pid = readfile(pidfile)
        os.kill(int(pid), signal.SIGKILL)
    except:
        pass

    for id in ids:
        try:
            vm_slot_put(int(id.strip()))
        except:
            pass

    try:
        shutil.rmtree(vmdir)
    except:
        pass


class ClusteredVM(object):
    """Defines a virtual machine object.
    """

    def __init__(self, vm_id, bridge, opts, vms_id, vm_tmpdir, vm_console):
        """Initialize the VM object with its essential data.
        """
        self.idnum    = vm_id
        self.vmsid    = vms_id
        self.bridge   = bridge
        self.ipaddr   = bridge.ipgen(vm_id)
        self.name     = "vm%d-%s" % (self.idnum, bridge.name)
        self.tapname  = self.name
        self.tmpdir   = vm_tmpdir
        self.console  = vm_console
        self.opts     = opts

        os.makedirs(self.tmpdir, 0700)

        self.tapdevs = []
        for iface_idx in range(int(self.opts.interfaces)):
            iface_name=self.tapname
            if iface_idx > 0:
                iface_name+="-"+str(iface_idx)

            td = { "name": iface_name,
                   "eth": "eth%d" % iface_idx,
                   "mac": bridge.macgen(vm_id, iface_idx) }
            self.tapdevs.append(td)

            subprocess.call(['sudo','-n', '--', 'ip', 'tuntap', 'del', 'dev', td["name"], 'mode', 'tap'], stdout=FNULL, stderr=FNULL)
            subprocess.check_call(['sudo', '-n', '--', 'ip', 'tuntap',
                                   'add', 'dev', td["name"],
                                   'mode', 'tap',
                                   'user', str(os.getuid()),
                                   'group', str(os.getgid())])
            atexit.register(subprocess.call, ['sudo','-n', '--', 'ip', 'tuntap', 'del', 'dev', td["name"], 'mode', 'tap'])

            subprocess.check_call(['sudo', '-n', '--', 'ip', 'link', 'set', 'dev', td["name"], 'up'])
            subprocess.check_call(['sudo', '-n', '--', 'brctl', 'addif', self.bridge.name, td["name"]])


    def run(self):
        opts = self.opts

        # setup run CD:
        if not opts.cdrom:
            self.iso=None
        elif os.path.isdir(opts.cdrom):
            self.iso = os.path.join(self.tmpdir,"run.iso")
            if subprocess.call(["genisoimage", "-quiet", "-R",
                                "-input-charset", "utf-8", "-o",
                                self.iso, opts.cdrom]):
                raise RuntimeError("Could not create cdrom from dir: "+opts.cdrom)
        else:
            self.iso = opts.cdrom

        # generates scratch drives:
        self.drives = []
        if opts.scratch:
            sizes = opts.scratch.split(",")
            i = 1;
            for size in sizes:
                if size.strip():
                    name = os.path.join(self.tmpdir,"disk-"+str(i))
                    i += 1
                    if subprocess.call(["fallocate", "-l", size, name]):
                        logging.warning("Error creating a "+size+" scratch drive with fallocate. Trying dd")
                        if subprocess.call(["dd", "if=/dev/zero", "of="+name, "count=1", "bs="+size]):
                            raise RuntimeError("Error creating a "+size+" scratch drive with dd")
                    self.drives.append(name)

        # build qemu command and start
        cmd = ["qemu-system-x86_64"]
        cmd.extend(["-machine", "accel=kvm"])
        cmd.extend(["-pidfile", os.path.join(self.tmpdir,"pid",)])
        cmd.extend(["-m", opts.mem])
        cmd.extend(["-smp", "%d,sockets=%d" % (int(opts.cpus), int(opts.cpus))])
        if opts.kernel:
            cmd.extend(["-kernel", opts.kernel])
            kernelParams = "console=ttyS0,115200 kgdboc=ttyS2,115200"
            kernelParams += " ip="+self.ipaddr
            if opts.append:
                kernelParams += " "+opts.append
            cmd.extend(["-append", kernelParams])
        if opts.initrd:
            cmd.extend(["-initrd", opts.initrd])
        cmd.extend(["-nographic"])
        cmd.extend(["-serial", self.console])
        cmd.extend(["-serial", "mon:unix:" + os.path.join(self.tmpdir,"con")+",server,nowait"])
        cmd.extend(["-serial", "unix:" + os.path.join(self.tmpdir,"gdb")+",server,nowait"])
        cmd.extend(["-monitor", "unix:" + os.path.join(self.tmpdir,"mon")+",server,nowait"])
        if opts.persistant:
            cmd.extend(["-drive", "format=raw,file="+opts.image])
        else:
            cmd.extend(["-drive", "format=raw,snapshot=on,file="+opts.image])
        if opts.filesystems:
            for fspath, fslabel in opts.filesystems:
                cmd.extend(["-virtfs", "local,path="+fspath+",mount_tag="+fslabel+",security_model=none"])
        for drive in self.drives:  # add scratch drives
            cmd.extend(["-drive", "if=virtio,format=raw,cache=writeback,file="+drive])
        if self.iso:              # add cdrom
            cmd.extend(["-cdrom", self.iso])

        for td in self.tapdevs:
            cmd.extend(["-netdev","tap,id="+td["eth"]+",ifname="+td["name"]+",script=no,downscript=no"])
            cmd.extend(["-device","virtio-net-pci,netdev="+td["eth"]+",mac="+td["mac"]])
            
        cmd.extend(["-device", "virtio-rng-pci"])

        self.proc = subprocess.Popen(cmd, shell=False, close_fds=True)

        with vm_slot_update(self.vmsid.vm_id) as vm:
            vm.pid = self.proc.pid

        return self.proc


class Cluster(object):
    """Defines a cluster of VMs attachd to a single virtual bridge.
    """

    SIGSET = (signal.SIGHUP,
              signal.SIGINT,
              signal.SIGQUIT,
              signal.SIGILL,
              signal.SIGABRT,
              signal.SIGFPE,
              signal.SIGPIPE,
              signal.SIGTERM,
              signal.SIGUSR1,
              signal.SIGUSR2)

    def __init__(self, num_of_vms, opts):
        """Initialize the cluster object with bridge information.
        """

        # Allow exit handlers to be called
        for sig in self.SIGSET:
            signal.signal(sig, lambda sig, frame: sys.exit(127))

        # Find an unused bridge and set self.name and self.idnum
        self.bridge_allocate()

        self.vms      = []                          # list of vms in cluster
        self.owner    = getpass.getuser()           # who "owns" this cluster

        self.tmpdir   = opts.tmpdir

        # Set the dnsmasq file attributes and wipe the files
        for dnattr in ["conf", "pid", "leases", "hostsfile", "addnhosts", "output"]:
            dnfile=os.path.join(self.tmpdir, "%s.dnsmasq.%s" % (self.name, dnattr))
            setattr(self, "dnsmasq_%s" % dnattr, dnfile)
            open(dnfile, 'w').close() # Truncate/create

        slotfile = os.path.join(self.tmpdir,'id')
        if os.path.exists(slotfile):
            os.remove(slotfile)

        if opts.indexfile:
            if os.path.exists(opts.indexfile):
                os.remove(opts.indexfile)

        # for each VM, grab a VM object and add it to cluster's VM list
        for vm in range(num_of_vms):

            vm_name = "vm%d-%s" % (vm+2, self.name)

            vm_tmpdir = os.path.join(self.tmpdir,
                vm_name+"-"+self.owner)

            slot = vm_slot_get(vm_tmpdir, self.ipgen(vm+2), opts.conx3)

            appendfile(slotfile, slot.vm_id)
            if opts.indexfile:
                appendfile(opts.indexfile, slot.vm_id)

            if vm == 0:
                vm_console = opts.console
            else:
                vm_console = 'file:%s' % os.path.join(vm_tmpdir, "console")

            self.vms.append(ClusteredVM(vm+2, self, opts, slot, vm_tmpdir, vm_console))


    # Network address generators indexed off node number for the MAC address,
    # IPv4 and IPv6 addresses.
    def bridge_allocate(self):
        self.cidr = 24
        self.v6cidr = 64

        for idnum in range(MIN_BRIDGE, MAX_BRIDGES):
            try:
                brname = "vmbr%d" % idnum
                subprocess.check_call(['sudo', '-n', '--', 'brctl', 'addbr', brname], stdout=FNULL, stderr=FNULL)
                atexit.register(subprocess.call, ['sudo', '-n', '--', 'brctl', 'delbr', brname])
                self.name = brname
                self.idnum = idnum
                break
            except subprocess.CalledProcessError:
                pass
        else:
            raise RuntimeError("No bridge entries available to start cluster")

        subprocess.check_call(['sudo', '-n', '--', 'brctl', 'stp', brname, 'on'])
        subprocess.check_call(['sudo', '-n', '--', 'brctl', 'setfd', brname, '2'])
        subprocess.check_call(['sudo', '-n', '--', 'brctl', 'sethello', brname, '2'])
        
        subprocess.check_call(['sudo', '-n', '--', 'ip', 'tuntap','add', 'dev', brname + "-host", 'mode', 'tap'])
        atexit.register(subprocess.call, ['sudo', '-n', '--', 'ip', 'tuntap','del', 'dev', brname + "-host", 'mode', 'tap'])
        
        subprocess.check_call(['sudo', '-n', '--', 'brctl', 'addif', brname, brname + "-host"])
        subprocess.check_call(['sudo', '-n', '--', 'sysctl', '-q', '-w', "net.ipv6.conf.%s.accept_ra=0" % brname, "net.ipv6.conf.%s.autoconf=0" % brname])

        subprocess.check_call(['sudo', '-n', '--', 'ip', 'link', 'set', 'dev', brname, 'up'])
        atexit.register(subprocess.call, ['sudo', '-n', '--', 'ip', 'link', 'set', 'dev', brname, 'down'])

        subprocess.call(['sudo', '-n', '--', 'iptables', '-t', 'filter', '-I', 'INPUT', '-i', brname, '-j', 'ACCEPT'])
        subprocess.call(['sudo', '-n', '--', 'iptables', '-t', 'filter', '-I', 'OUTPUT', '-o', brname, '-j', 'ACCEPT'])
        subprocess.call(['sudo', '-n', '--', 'iptables', '-t', 'filter', '-I', 'FORWARD', '-i', brname, '-j', 'ACCEPT'])
        subprocess.call(['sudo', '-n', '--', 'iptables', '-t', 'filter', '-I', 'FORWARD', '-o', brname, '-j', 'ACCEPT'])

        atexit.register(subprocess.call, ['sudo', '-n', '--', 'iptables', '-t', 'filter', '-D', 'INPUT', '-i', brname, '-j', 'ACCEPT'])
        atexit.register(subprocess.call, ['sudo', '-n', '--', 'iptables', '-t', 'filter', '-D', 'OUTPUT', '-o', brname, '-j', 'ACCEPT'])
        atexit.register(subprocess.call, ['sudo', '-n', '--', 'iptables', '-t', 'filter', '-D', 'FORWARD', '-i', brname, '-j', 'ACCEPT'])
        atexit.register(subprocess.call, ['sudo', '-n', '--', 'iptables', '-t', 'filter', '-D', 'FORWARD', '-o', brname, '-j', 'ACCEPT'])

        # NAT IPv4 packets off the bridge if supported.  The iptables
        # configuration depends on iptables on the server not being
        # used for anything else.
        subprocess.call(['sudo', '-n', '--', 'sysctl', '-q', '-w', 'net.ipv4.ip_forward=1'])

        subprocess.check_call(['sudo', '-n', '--', 'ip', 'addr', 'add', "%s/%d" %(self.ipgen(1), self.cidr), "dev", brname])
        subprocess.check_call(['sudo', '-n', '--', 'ip', 'addr', 'add', "%s/%d" %(self.ipv6gen(1), self.v6cidr), "dev", brname])

        subprocess.call(['sudo', '-n', '--', 'iptables', '-t', 'nat', '-I', 'POSTROUTING', '-s', "%s/%d" % (self.ipgen(0), self.cidr), '!', '-o', brname, '-j', 'MASQUERADE'])

        atexit.register(subprocess.call, ['sudo', '-n', '--', 'iptables', '-t', 'nat', '-D', 'POSTROUTING', '-s', "%s/%d" % (self.ipgen(0), self.cidr), '!', '-o', brname, '-j', 'MASQUERADE'])

    def macgen(self, node, ifnum=0):
        return "de:ad:be:%0.2x:%0.2x:%0.2x" % (ifnum, self.idnum, node)

    def ipgen(self, node):
        return "172.30.%d.%d" % (self.idnum, node)

    def ipv6gen(self, node):
        return "fd84:c772:8103:%0.4x::%0.4x" % (0xfa00 + self.idnum, node)


    def enable_dnsmasq(self):
        """Configure and start dnsmasq
        
        IPv4 will have explicit host entries (hostsfile).

        IPv6 will use router advertisement to pick a random address
        due to the difficulty of determining the DUID-LT in advance.
        """
        with open(self.dnsmasq_conf, "w") as f:
            f.write("strict-order\n")
            f.write("domain-needed\n")
            f.write("domain=%s\n" % self.name)
            f.write("expand-hosts\n")
            f.write("local=/%s/\n" % self.name)
            f.write("pid-file=%s\n" % self.dnsmasq_pid)
            f.write("except-interface=lo\n")
            f.write("bind-interfaces\n")
            f.write("interface=%s\n" % self.name)
            f.write("dhcp-range=%s,%s\n" % (self.ipgen(128), self.ipgen(254)))
            f.write("dhcp-no-override\n")
            f.write("dhcp-range=%s,constructor:%s,slaac,ra-names,%d\n" % (self.ipv6gen(1), self.name, self.v6cidr))
            f.write("dhcp-leasefile=%s\n" % self.dnsmasq_leases)
            f.write("dhcp-lease-max=383\n")
            f.write("dhcp-hostsfile=%s\n" % self.dnsmasq_hostsfile)
            f.write("addn-hosts=%s\n" % self.dnsmasq_addnhosts)

        with open(self.dnsmasq_hostsfile, "w") as f:
            for idx in range(2, 127):
                f.write("%s,%s,node%d\n" % (self.macgen(idx), self.ipgen(idx), idx-1))

        cmd = ['sudo', '-n', '--', 'dnsmasq',
               "--log-facility=-", '--log-queries',
               "--conf-file=%s" % self.dnsmasq_conf, 
               "--user=%s" % self.owner]
        subprocess.check_call(cmd, shell=False, close_fds=True,
                              stdin=FNULL,
                              stdout=open(self.dnsmasq_output, 'w'),
                              stderr=subprocess.STDOUT)

        # Wait up to 1 minute for dnsmasq to stabilize
        etime = time.time() + 60.0
        while (time.time() <= etime):
            time.sleep(1.0)
            try:
                with open(self.dnsmasq_pid, 'r') as f:
                    pid=int(f.read().strip())
                    if pid > 0:
                        atexit.register(self.disable_dnsmasq, pid)
                        break
            except (OSError, IOError):
                pass
        else:
            raise RuntimeError("Dnsmasq failed to start in time")

    def disable_dnsmasq(self, pid):
        try:
            os.kill(pid, signal.SIGKILL)
        except:
            logging.warning("Failed to terminate dnsmasq")


    # Tear down VMs and networking on a signal or abort
    def terminate_vms(self):
        for vm in self.vms:
            try:
                vm.proc.terminate()
            except:
                pass

    def run(self):
        """Setup and run the cluster.
        """
        for sig in self.SIGSET:
            signal.signal(sig, lambda sig, frame: self.terminate_vms())

        # Setup dnsmasq on the bridge
        self.enable_dnsmasq()

        # Launch the VMs
        for vm in self.vms:
            vm.run()

        # Collect VMs as they finish
        while True:
            for vm in self.vms:
                vm.proc.poll()

            for vm in self.vms:
                if vm.proc.returncode == None:
                    break # Re-poll
            else:
                break # Abort the poll loop
            time.sleep(0.5)

        for vm in self.vms:
            try:
                vm_slot_put(vm.vmsid)
            except:
                logging.warning("Failed to return the slot for %d" % vm.vmsid)

def cmd_start():
    """Start new virtual machines
    """
    opt = OptionParser("Usage: %prog start [options] [number]",
        description="Start a virtual machine or cluster")

    opt.add_option("-d", "--debug", dest="debug",
                   default=False, action="store_true",
        help="enable debugging")

    opt.add_option("-i", "--image", dest="image",
        help="boot image of the virtual machine(s)")

    opt.add_option("-k", "--kernel", dest="kernel",
        help="kernel used to boot the virtual machine(s)")

    opt.add_option("-r", "--initrd", dest="initrd",
        help="initial ramdisk for boot")

    opt.add_option("-a", "--append", dest="append",
        default="root=/dev/sda rw",
        help="append kernel command line boot arguments")

    opt.add_option("-c", "--cdrom-source", dest="cdrom",
        help="cdrom image or directory to convert into a cdrom image")

    opt.add_option("-s", "--scratch-dev ", dest="scratch",
        default="",
        help="list of scratch device sizes. ex: 256M,2G")

    opt.add_option("-t", "--tmpfs-dir", dest="tmpfs",
        default=DEFAULT_TMP,
        help="location of the tmpfs directory for scratch devices")

    opt.add_option("-m", "--memory", dest="mem",
        default=DEFAULT_MEMORY,
        help="amount of memory to be allocated per VM")

    opt.add_option("-C", "--core", dest="core",
        default=None,
        help="file used for log and core")

    opt.add_option("--cpus", dest="cpus",
        default="1",
        help="number of CPUs allocated per VM")

    opt.add_option("-p", "--persistant", dest="persistant",
        action="store_true",
        help="use writeback")

    opt.add_option("--fs", dest="filesystems",
        action="append", nargs=2,
        help="mount a directory (first argument) as " +
        "a filesystem label (second argument) in the VM")

    opt.add_option("--id", dest="indexfile",
        help="file to write vm number to")

    opt.add_option("--console", dest="console",
        default="stdio",
        help="where to attach the vm console (ex: stdio, file:foo)")

    opt.add_option("--conx3", dest="conx3",
        default=False, action="store_true",
        help="assign a virtual pci connect x3 nic for rdma")

    opt.add_option("--cluster", dest="cluster",
        help="Start a cluster with the specified number of nodes")

    opt.add_option("--interfaces", dest="interfaces",
                   default="1",
                   help="Specify the number of interfaces on the cluster nodes")

    (options, args) = opt.parse_args()

    if options.debug:
        logging.getLogger().setLevel("DEBUG")

    tmpdate = datetime.datetime.strftime(
        datetime.datetime.today(),"%Y%m%d-%H%M%S")
    
    options.tmpdir = os.path.join(
        options.tmpfs,"vm-%s-%s" % (tmpdate, randstr()))

    # generate tmp dir
    os.makedirs(options.tmpdir, 0700)
        
    if options.cluster:
        
        cluster = Cluster(int(options.cluster),options)

        cluster.run()

    else:

        # path for single vm

        if not options.image:
            raise RuntimeError("Requires an image to boot")

        if not os.path.isfile(options.image):
            raise RuntimeError("Cannot find base image file: "+options.image)

        #if not options.kernel:

        if options.kernel and not os.path.isfile(options.kernel):
            raise RuntimeError("Cannot find kernel file: "+options.kernel)

        if options.initrd and not os.path.isfile(options.initrd):
            raise RuntimeError("Cannot find initrd file: "+options.initrd)

        try:
            caught_signal = [False]

            def sighandler(signum, stack):
                if not caught_signal[0]:
                    caught_signal[0] = True
                    raise Exception("signal caught")

            for i in [x for x in dir(signal) if x.startswith("SIG")]:
                if i in ['SIGHUP', 'SIGINT', 'SIGQUIT', 'SIGILL', 'SIGABRT',
                    'SIGFPE', 'SIGSEGV', 'SIGPIPE', 'SIGALRM', 'SIGTERM',
                    'SIGUSR1', 'SIGUSR2']:
                    signum = getattr(signal, i)
                    signal.signal(signum, sighandler)

            vm = vm_slot_get(options.tmpdir, None, options.conx3)

            idfile = os.path.join(options.tmpdir,'id')

            writefile(idfile, vm.vm_id)
            if options.indexfile:
                writefile(options.indexfile, vm.vm_id)

            # setup run CD:
            if not options.cdrom:
                iso=None
            elif os.path.isdir(options.cdrom):
                iso = options.tmpdir + "/run.iso"
                if subprocess.call(["genisoimage", "-quiet", "-R",
                    "-input-charset",
                    "utf-8", "-o", iso, options.cdrom]):
                    raise RuntimeError("Could not create cdrom from dir: "+options.cdrom)
            else:
                iso=options.cdrom

             # generates scratch drives:
            drives = []
            if options.scratch:
                sizes = options.scratch.split(",")

                i = 1;
                for size in sizes:
                    if size.strip():
                        name = options.tmpdir + "/disk-" + str(i)
                        i += 1

                        if subprocess.call(["fallocate", "-l", size, name]):
                            logging.warning("fallocate error, trying dd")
                            if subprocess.call(["dd", "if=/dev/zero", "of="+name,
                                "count=1", "bs="+size]):
                               raise RuntimeError("error creating scratch drive '"+name+"'")
                        drives.append(name)

            # generate log and core dump device
            if options.core:
                (name,size) = options.core.split(",")
                if size==None:
                    size="10G"
                if subprocess.call(["fallocate", "-l", size, name]):
                    logging.warning("fallocate error, trying dd")
                    if subprocess.call(["dd", "if=/dev/zero", "of="+name,
                                        "count=1", "bs="+size]):
                        raise RuntimeError("error creating core/log drive '"+name+"'")
                if subprocess.call(["mkfs.ext4", "-U","11111111-2222-3333-4444-555555555555","-F",name]):
                    raise RuntimeError("mkfs.ext4 failed on '"+name+"'")


            # build qemu command and start
            cmd = ["qemu-system-x86_64"]
            cmd.extend(["-machine", "accel=kvm"])
            cmd.extend(["-pidfile", options.tmpdir + "/pid"])
            cmd.extend(["-m", options.mem])
            cmd.extend(["-smp", "%d,sockets=%d" % (int(options.cpus), int(options.cpus))])

            if options.kernel:
                cmd.extend(["-kernel", options.kernel])
                kernelParams = "console=ttyS0,115200 kgdboc=ttyS2,115200"
                if options.append:
                    kernelParams += " "+options.append
                cmd.extend(["-append", kernelParams])

            if options.initrd:
                cmd.extend(["-initrd", options.initrd])

            cmd.extend(["-nographic"])
            cmd.extend(["-serial",  options.console])
            cmd.extend(["-serial",  "mon:unix:" + options.tmpdir + "/con,server,nowait"])
            cmd.extend(["-serial",  "unix:" + options.tmpdir + "/kgdb,server,nowait"])
            cmd.extend(["-monitor", "unix:" + options.tmpdir + "/mon,server,nowait"])
            cmd.extend(["-gdb", "unix:" + options.tmpdir + "/gdb,server,nowait"])
    
            # Drives:
            if options.persistant:
                cmd.extend(["-drive", "format=raw,file="+options.image])
            else:
                cmd.extend(["-drive", "format=raw,snapshot=on,file="+options.image])
            if options.filesystems:
                for fspath, fslabel in options.filesystems:
                    cmd.extend(["-virtfs", "local,path="+fspath+",mount_tag="+fslabel+",security_model=none"])
            if options.core:
               cmd.extend(["-drive", "format=raw,file="+options.core.split(",")[0]])

            for drive in drives:  # add scratch drives
                cmd.extend(["-drive", "if=virtio,format=raw,cache=writeback,file="+drive])

            if iso:              # add cdrom
                cmd.extend(["-cdrom",iso])
 
            cmd.extend(["-net", "nic,model=virtio"])
            cmd.extend(["-net", "user,host=10.0.2.2,restrict=off,hostfwd=tcp:127.0.0.1:" + str(vm.vm_id + 9000) + "-:22"])
    
            if options.conx3:
                print "Assigning vf: ", vm.conx3_id
                cmd.extend(["-device", "pci-assign,host="+str(vm.conx3_id)])
        
            cmd.extend(["-device", "virtio-rng-pci"])

            logging.warning("Executing: "+str(cmd))
            
            p = subprocess.Popen(cmd, shell=False)

            with vm_slot_update(vm.vm_id) as vm:
                vm.pid = p.pid

            print GREEN+"Vm ID: "+str(vm.vm_id)+NC
    
            p.wait()
            caught_signal[0] = True
        except:
            pass
    
    vm_cleanup(options.tmpdir)
    subprocess.call(["stty", "sane"],
                    stdout=FNULL,
                    stderr=subprocess.STDOUT)

    try:
        sys.stdout.flush()
    except:
        pass

def cmd_stop():
    """Stop virtual machines by id or ipaddr
    """

    opt = OptionParser("Usage: %prog stop [options] [id]",
        description="Stop a vm by its id or its ip address")

    opt.add_option("-d", "--debug", dest="debug",
                   default=False, action="store_true",
        help="enable debugging")

    opt.add_option("-i", "--ip", dest="ipaddr",
      help="The ip address of the vm")

    (opts, args) = opt.parse_args()

    if opts.debug:
        logging.getLogger().setLevel("DEBUG")


    if opts.ipaddr:
        os.system(
          "ssh -o StrictHostKeyChecking=no -i id_dsa %s 'shutdown -h now'"
          % opts.ipaddr)
    else:

        if len(args) == 0:
            raise RuntimeError("Please provide a vm id or ip address to stop")

        ids = args[0].split("/") 
        
        for id in ids:
            vm = vm_lookup(int(id))
            if (vm.pid is not None) and vm.exists():
                os.kill(vm.pid, signal.SIGKILL)


def cmd_ssh():
    """ssh into a virtual machine"""

    if len(sys.argv) <= 1:
        raise RuntimeError("Please provide a vm id to SSH to")

    id = int(sys.argv[1].split('/')[0])
    vm = vm_lookup(id)

    if not vm.exists():
        raise RuntimeError("VM is not running")

    keyfile = os.path.dirname(os.path.realpath(__file__)) + "/id_dsa"
    os.system("chmod 600 " + keyfile)

    if vm.ip and (vm.ip[:7]!='172.20.'):
        cmd = ["ssh", "-o", "StrictHostKeyChecking=no", "-o",
            "UserKnownHostsFile=/dev/null", "-i", keyfile, "root@"+vm.ip]
    else:
        cmd = ["ssh", "-o", "NoHostAuthenticationForLocalhost=yes",
            "-i", keyfile, "-p", str(9000 + id), "root@127.0.0.1"]

    cmd.extend(sys.argv[2:])
    os.execvp("ssh", cmd)


def vm_gdb(gdbsocket):
    if len(sys.argv) <= 2:
        raise RuntimeError("Please provide a vm ID and a vmlinux file")

    vm = vm_lookup(int(sys.argv[1]))
    os.execlp("gdb", "gdb",
          "-ex", "set remote interrupt-on-connect",
          "-ex", "target remote | socat UNIX-CONNECT:" +
          os.path.join(vm.tmpdir, gdbsocket) + ' -', sys.argv[2])


def cmd_gdb():
    vm_gdb('gdb')


def cmd_kgdb():
    vm_gdb('kgdb')


def cmd_mon():
    if len(sys.argv)<=1:
        raise RuntimeError("Please provide a vm id")

    vm = vm_lookup(int(sys.argv[1]))

    os.execlp("minicom", "minicom",
          "-D", "unix#" + vm.tmpdir + "mon")

def cmd_check():
    """Check if a specific resource is available
    """

    opt=OptionParser("usage: %prog vm list [session_id]",
             description="""List out running VMs""")

    opt.add_option("-d", "--debug", dest="debug",
                   default=False, action="store_true",
        help="enable debugging")

    (options, args) = opt.parse_args()

    if options.debug:
        logging.getLogger().setLevel("DEBUG")

    if len(args) == 0 or args[0] == "vms":
        d = openLockedDb(IP_FILE_LOCK, IP_FILE_DICT)
        running_vms = d["running_vms"]
        closeLockedDb(d)
        if (MAX_VMS - len(running_vms)) == 0:
            raise RuntimeError("No VMs available")

    elif args[0] == "bridges":
        for br_id in range(MAX_BRIDGES):
            try:
                subprocess.check_call(['/sbin/brctl', 'showmacs', "vmbr%d" % br_id], stdout=FNULL, stderr=FNULL)
            except subprocess.CalledProcessError:
                break
        else:
            raise RuntimeError("No bridges available")

    elif args[0] == "conx3":
        d = openLockedDb(IP_FILE_LOCK, IP_FILE_DICT)
        running_vms=d["running_vms"]
        closeLockedDb(d)
        cards = list_conx3()
        for vm in running_vms:
            if vm.conx3_id in cards:
                cards.remove(vm.conx3_id)
        if len(cards) == 0:
            raise RuntimeError("ConnectX3 is not available")


def cmd_list():
    """List out running VMs"""
    opt=OptionParser("usage: %prog vm list [session_id]",
             description="""List out running VMs""")

    opt.add_option("-d", "--debug", dest="debug",
                   default=False, action="store_true",
        help="enable debugging")


    (options, args) = opt.parse_args()

    if options.debug:
        logging.getLogger().setLevel("DEBUG")

    if len(args) == 0 or args[0] == "vms":
        
        # get running vms:
        d = openLockedDb(IP_FILE_LOCK, IP_FILE_DICT)
        running_vms = d["running_vms"]
        closeLockedDb(d)
    
        running_vms = sorted(running_vms, key=operator.attrgetter("owner", "vm_id"))
    
        print "Domain\tIP\t\tConX3 id\tOwner\tPID"
        print "------\t------------\t--------\t-----\t-----"
    
        for vm in running_vms:
            vpid=str(vm.pid) if vm.exists() == True else "DEAD"
            print (str(vm.name) + "\t" + str(vm.ip) + "\t" +
                   str(vm.conx3_id) + "\t\t" +
                   str(vm.owner) + "\t" + vpid)

    elif args[0] == "bridges":
        print "bridge name\tbridge id"
        for br_id in range(MAX_BRIDGES):
            try:
                brout=subprocess.check_output(['/sbin/brctl', 'show', "vmbr%d" % br_id], stderr=FNULL)
                for l in brout.split("\n"):
                    m = re.match('^(vmbr\d+)\s+([0-9a-f]+\.[0-9a-f]+)', l)
                    if m:
                        print "%s\t\t%s" % (m.group(1), m.group(2))
            except subprocess.CalledProcessError:
                pass

    elif args[0] == "conx3":
        cards = list_conx3()
        print "Cards"
        print "-------"
        for card in cards:
            print card

cmd_ls = cmd_list

def cmd_purge():
    """Purge entries from a partially broken database"""

    opt=OptionParser("usage: %prog purge [object, object, ...]",
             description="""Purge entries from a partially broken database""")

    opt.add_option("-d", "--debug", dest="debug",
                   default=False, action="store_true",
        help="enable debugging")

    (options, args) = opt.parse_args()

    if options.debug:
        logging.getLogger().setLevel("DEBUG")

    vms_by_id=[]
    vms_by_name=[]
    brs_by_name=[]
    for entry in args:
        if (entry[:2] == "vm") and entry[2:].isdigit():
            vms_by_name.append(entry)
        elif (entry[:4] == "vmbr") and entry[4:].isdigit():
            brs_by_name.append(entry)
        elif entry.isdigit():
            vms_by_id.append(int(entry))
        else:
            raise ValueError("Cannot infer type of entry: %s" % entry)

    # Copied from all the atexit.register calls in the bridge code
    for brname in brs_by_name:
        for vmif in range(MAX_VMS):
            logging.debug("Purging: vm%d-%s" % (vmif, brname))
            subprocess.call(['sudo','-n', '--', 'ip', 'tuntap', 'del', 'dev', "vm%d-%s" % (vmif, brname), 'mode', 'tap'])
            for vmidx in range(1,8):
                logging.debug("Purging: vm%d-%s-%d" % (vmif, brname, vmidx))
                subprocess.call(['sudo','-n', '--', 'ip', 'tuntap', 'del', 'dev', "vm%d-%s-%d" % (vmif, brname, vmidx), 'mode', 'tap'])

        # The MASQUERADE rule is a bit more complicated, let that leak for now
        # Tearing down dnsmasq is more complicated as well
        logging.debug("Purging iptables rules for %s" % brname)
        subprocess.call(['sudo', '-n', '--', 'iptables', '-t', 'filter', '-D', 'INPUT', '-i', brname, '-j', 'ACCEPT'], stdout=FNULL, stderr=FNULL)
        subprocess.call(['sudo', '-n', '--', 'iptables', '-t', 'filter', '-D', 'OUTPUT', '-o', brname, '-j', 'ACCEPT'], stdout=FNULL, stderr=FNULL)
        subprocess.call(['sudo', '-n', '--', 'iptables', '-t', 'filter', '-D', 'FORWARD', '-i', brname, '-j', 'ACCEPT'], stdout=FNULL, stderr=FNULL)
        subprocess.call(['sudo', '-n', '--', 'iptables', '-t', 'filter', '-D', 'FORWARD', '-o', brname, '-j', 'ACCEPT'], stdout=FNULL, stderr=FNULL)

        logging.debug("Purging host interface for %s" % brname)
        subprocess.call(['sudo', '-n', '--', 'ip', 'tuntap','del', 'dev', brname + "-host", 'mode', 'tap'], stdout=FNULL, stderr=FNULL)

        logging.debug("Purging bridge %s" % brname)
        subprocess.call(['sudo', '-n', '--', 'ip', 'link', 'set', 'dev', brname, 'down'], stdout=FNULL, stderr=FNULL)
        subprocess.call(['sudo', '-n', '--', 'brctl', 'delbr', brname], stdout=FNULL, stderr=FNULL)

    vmdb = openLockedDb(IP_FILE_LOCK, IP_FILE_DICT)
    running_vms = vmdb["running_vms"]
    new_vms = []
    for vm in running_vms:
        if (vm.vm_id in vms_by_id) or (vm.name in vms_by_name):
            if (vm.pid is not None) and vm.exists():
                os.kill(vm.pid, signal.SIGKILL)
        else:
            new_vms.append(vm)

    vmdb["running_vms"] = new_vms
    closeLockedDb(vmdb)
    


def gendbs(dbname, description, lockfile, dbfile, callback):
    """Generic function to generate database files (union of duplicated code).

    cmdname       Name of the database being created (ips, bridges)
    description   Help text
    lockfile      Name of the lockfile to be created
    dbfile        Name of the database file to be created
    callback      callable object to populate the database
                  (passed an open shelve object as its argument)
    """
    opt=OptionParser("usage: %prog vm gen" + dbname,
                     description=description)

    opt.add_option("-d", "--debug", dest="debug",
                   default=False, action="store_true",
        help="enable debugging")

    opt.add_option("-s", "--safe", dest="safe",
                   default=False, action="store_true",
                   help="Automatic, but only if the lock and dbfile do not exist")
    opt.add_option("-f", "--force", dest="force",
                   default=False, action="store_true",
                   help="Automatic, force overwrite")
    (options, args) = opt.parse_args()

    if options.debug:
        logging.getLogger().setLevel("DEBUG")

    if options.force and options.safe:
        raise RuntimeError("--safe and --force are mutually exclusive")

    if os.geteuid() != 0:
        raise RuntimeError("Root permissions are required")

    if not (options.force or options.safe):
        check = raw_input("This will overwrite any current %s database files. Are you sure? (y): " % dbname)
        if check != "y":
            sys.exit(0)

    # make directory
    try:
        os.mkdir("/etc/vms")
    except OSError as e:
        if e.errno != errno.EEXIST:
            raise

    lockFD = os.open(lockfile, os.O_RDWR | os.O_CREAT)
    try:
        if options.safe:
            fcntl.flock(lockFD, fcntl.LOCK_EX)
            if os.path.exists(dbfile):
                print "Already setup"
                return

        os.fchmod(lockFD, 0666)
        os.lseek(lockFD, 0, os.SEEK_SET)
        os.ftruncate(lockFD, 0)
        os.write(lockFD, "used for locking access to %s database file" % dbname)

        db = shelve.open(dbfile)
        db["sess_id"]=1000

        callback(db)

        db.close()
        os.chmod(dbfile, 0666)

        print "Setup completed"

    finally:
        # This will implicitly release the lock
        os.close(lockFD)


def cmd_genips():
    """
    Generates a new set of new IP Macaddress combinations for
    and puts them in the proper locations:
    Vm.ips-dict - shelve dictionary used by python

    For use when setting up networking on a new machine, or if
    any of the config files get screwed up.
    """

    def ips_generator(d):
        d["running_vms"] = []

    gendbs("ips", "Generate a new IP/MAC file", IP_FILE_LOCK, IP_FILE_DICT, ips_generator)


def list_conx3():
    """Return the device IDs of all Mellanox ConnectX-3 Virtual Functions
       on the system which are detached from the Mellanox driver and
       are usable for VMs.
    
    Note:

    This requires system preparation to create the virtual, detached cards.

    On the debian machines, /etc/rc.local should use the following commands to reserve
    virtual functions for VMs:
    rmmod mlx4_ib
    rmmod mlx4_core
    echo '15b3 1004' > /sys/bus/pci/drivers/pci-stub/new_id
    modprobe mlx4_core num_vfs=16 probe_vf=16

    As we get new versions of the cards, the above stanza and this
    code needs to be updated to reflect proper PCI device IDs.
    """
    cards=[]

    for ent in os.listdir(CX3_PCI_STUB_DIR):
        devent = os.path.join(CX3_PCI_STUB_DIR, ent)
        try:
            with open(os.path.join(devent, "vendor")) as f:
                dev_vendor = int(f.read().strip(),16)
            with open(os.path.join(devent, "device")) as f:
                dev_device = int(f.read().strip(),16)
            if ((dev_vendor in CX3_VENDOR_IDS) and (dev_device in CX3_DEVICE_IDS)):
                cards.append(':'.join(ent.split(':')[1:]))
        except IOError as e:
            if e.errno not in (errno.ENOENT, errno.ENOTDIR):
                raise

    return cards


def cmd_help():
    """Print help for commands."""
    print """Usage: vm-start [command] [args]

  Commands:
    start       setup and start a vm or a vm cluster
    stop        stop a vm by id or, for a cluster,
                all vms or a single by name
    ssh         ssh to a virtual machine by id
    gdb         connect to gbd
    kgdb        connect to kgdb
    mon         connect to the qemu monitor
    check       check whether there are free resources
    list        list all running vms
    genips      generate a fresh vm database
    help        print help for commands
    """

"""Main program."""

# Configure logging
logging.basicConfig(stream=sys.stderr,format='%(levelname)s: %(message)s',level=logging.WARNING)

try:
    # if there is no command or args, print error message
    if len(sys.argv) == 1:
        cmd_help()
        raise RuntimeError("Please provide a command and appropriate arguments.")

    # if first arg is a help option or command, print help and exit
    if sys.argv[1] in ["-h", "--help", "help"]:
        cmd_help()
        sys.exit(0)

    # try to find the command in the global namespace
    try:
        _cmd_name = "cmd_" + sys.argv[1]
        _cmd_func = getattr(sys.modules[__name__], _cmd_name)
    except AttributeError:
        raise RuntimeError("<%s> is not a valid command.\n" % sys.argv[1] +
          "Try 'vm-cluster help' for more info.")

    # remove the command from argv and execute the command function
    sys.argv.pop(1)
    _cmd_func()
except Exception as e:
    logging.error("%s: %s" % (type(e).__name__, e))
    logging.debug(traceback.format_exc())
    sys.exit(1)

sys.exit(0)
