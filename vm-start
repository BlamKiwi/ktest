#!/usr/bin/python
# Copyright (c) 2013 Datera, Inc. All rights reserved
# Datera, Inc. Confidential and Propriatory

import getpass
import sys
import os
import errno
import fcntl
import subprocess
import shelve
import shutil
import signal
import operator
import time
import string
import random
import re
import datetime
import select
import inspect

def lineno():
    """Returns the current line number in our program."""
    return inspect.currentframe().f_back.f_lineno

from optparse import OptionParser, OptionGroup

# script directory and path
DIR=os.path.dirname(__file__)       # path to script directory

# global info file settings:
IP_FILE = "/etc/vms/ips"
IP_FILE_LOCK = IP_FILE+".lock"      # File to lock access to VM list
IP_FILE_DICT = IP_FILE+".dict"      # Shelf file to store vm list

CX3_FILE = "/etc/vms/pci_connectx3"
CX3_FILE_LOCK = CX3_FILE+".lock"    # File to lock access to PCI_CONNECTX3 info
CX3_FILE_DICT = CX3_FILE+".dict"    # Shelf file to store PCI_CONNECTX3 info

BR_FILE = "/etc/vms/bridges"
BR_FILE_LOCK = BR_FILE+".lock"      # File to lock access to bridge info
BR_FILE_DICT = BR_FILE+".dict"      # Shelf file to store bridge info

MAX_VMS = 100                       # Max number of VMs. Currently this is pretty arbitrary.

DEFAULT_MEMORY = "1G"               # how much memory to give the vms
DEFAULT_TMP = "/tmp"                # default directory for tmps
DEFAULT_TIMEOUT = 10*60             # timeout: 10 mins

USER_NETWORKING = True

# colors:
GREEN='\033[32m'
CYAN='\033[36m'
NC='\033[0m'

DEVNULL = open(os.devnull, "wb")

DEBUG = False

"""
Print Error:
"""
def die(msg, exitStatus=1):
    print >> sys.stderr, "[error] "+msg
    sys.exit(exitStatus)

def warning(msg):
    print >> sys.stderr, "[warning] "+msg

def debug(msg):
    if DEBUG:
        print >> sys.stderr, "[debug] "+msg

def randstr(size=8, chars=string.letters + string.digits):
    return "".join(random.choice(chars) for x in range(size))

def readfile(filename):
    with open(filename, 'r') as f:
        line = f.readline()
    return line

def writefile(filename, line):
    debug("in writefile - writing <%s> into %s" % (line,filename))
    with open(filename, 'w') as f:
        f.write(str(line)+"\n")

def appendfile(filename, line):

    newline = ""
    if os.path.exists(filename):
        with open(filename, 'r') as f:
            newline = f.read()
            newline = newline.strip()
            newline += "/"
                   
    newline += str(line)
    debug("in appendfile - writing <%s> into %s" % (newline,filename))
    with open(filename, 'w') as f:
        f.write(newline+"\n")  

"""
Functions of opening shelf to lock while
reading and writing to shelf file
"""
def openLockedDb(file_lock, file_dict):
    lockFD = os.open(file_lock, os.O_RDONLY)
    fcntl.flock(lockFD, fcntl.LOCK_EX)
    db = shelve.open(file_dict)
    db.lockFD = lockFD
    return db

def closeLockedDb(db):
    db.close()
    fcntl.flock(db.lockFD, fcntl.LOCK_UN)
    os.close(db.lockFD)

class Bridge:
    """Represents a single bridge"""
    def __init__ (self, br_key, br_num, br_name):
        self.br_key = br_key       # string bridge key
        self.br_num = br_num       # integer bridge number
        self.br_name = br_name     # bridge name
        self.available = True      # available?

class Domain:
    """Represents a single virtual machine"""
    def __init__ (self, vm_id, ip, mac):
        self.vm_id = vm_id         # id number for this vm
        self.ip = ip               # ip address
        self.mac = mac             # mac addresss
        self.owner = None          # who started this machine
        self.name = "vm"+str(vm_id)   # name of the vm, can be custom
        self.tmpdir  = None        # the location of dir to store scratch drives
        self.conx3_id = None     # dev id of the virtual pci x3 Connect X3 card

    def exists(self):
        """Does the VM this represents actually exists?"""
        if subprocess.call(['pgrep', '--pidfile', self.tmpdir + '/pid',
            'qemu-system-x86'],
            stdout=DEVNULL, stderr=DEVNULL):
            return False
        return True

def bridge_free(br_key):
    db = openLockedDb(BR_FILE_LOCK, BR_FILE_DICT)
    bridges = db["bridges"]

    bridges[br_key].available = True

    db["bridges"] = bridges
    closeLockedDb(db)
    
def bridge_get():
    db = openLockedDb(BR_FILE_LOCK, BR_FILE_DICT)
    bridges = db["bridges"]

    keys = bridges.keys()
    keys.sort()
    
    bridge = None
    for key in keys:
        if bridges[key].available:
            bridge = bridges[key]
            bridge.available = False
            bridges[key] = bridge
            break
    else:
        die("No bridge entries available to start cluster")        

    db["bridges"] = bridges
    closeLockedDb(db)
    return bridge


def vm_conx3_put(conx3_id):
    db = openLockedDb(CX3_FILE_LOCK, CX3_FILE_DICT)
    free_conx3 = db["free_conx3"]
    free_conx3.append(conx3_id)
    db["free_conx3"] = free_conx3
    closeLockedDb(db)

def vm_conx3_get():
    db = openLockedDb(CX3_FILE_LOCK, CX3_FILE_DICT)
    free_conx3 = db["free_conx3"]
    if len(free_conx3) == 0:
        closeLockedDb(db)
        die("Not enough virtual connect x3 to start a vms")
    print free_conx3
    conx3_id = free_conx3.pop()
    while conx3_id=="08:02.0":
       conx3_id = free_conx3.pop()
       # this device is incorrectly reported one that can be used,
       # however it does not work si we just drop it.
    print "conx3_id=",conx3_id
    db["free_conx3"] = free_conx3
    closeLockedDb(db)
    return conx3_id

def vm_slot_put(id):
    d = openLockedDb(IP_FILE_LOCK, IP_FILE_DICT)
    running_vms = d["running_vms"]
    vm = next((vm for vm in running_vms if vm.vm_id == id), None)

    if not vm:
        closeLockedDb(d)
        return

    running_vms.remove(vm)
    d["running_vms"] = running_vms

    vm.state    = "stopped"
    vm.owner    = None
    vm.pid  = None
    vm.name = "vm"+str(vm.vm_id)
    vm.base = None
    vm.kernel   = None
    vm.tmpdir   = None
    vm.vde  = None
    vm.ip   = None

    if vm.conx3_id is not None:
        vm_conx3_put(vm.conx3_id)

    free_vms = d["free_vms"]
    free_vms.append(vm)
    d["free_vms"] =  sorted(free_vms, key=operator.attrgetter("vm_id"), reverse=True)
    closeLockedDb(d)

def vm_slot_get(tmpdir, ip, conx3):
    try:
        user = os.environ["SUDO_USER"]
    except KeyError:
        user = os.environ["USER"]

    if conx3:
        conx3_id = vm_conx3_get()
    else:
        conx3_id = None

    #load database:
    d = openLockedDb(IP_FILE_LOCK, IP_FILE_DICT)
    free_vms = d["free_vms"]

    # check to make sure we have a free vm entry
    if len(free_vms) == 0:
        closeLockedDb(d)
        if conx3_id is not None:
            vm_conx3_put(vm.conx3_id)
        die("No vm entries available to start a vm")

    # get vm entr, mark for setup
    vm = free_vms.pop()
    vm.state    = "setup"
    vm.owner    = user
    vm.tmpdir   = tmpdir
    vm.conx3_id = conx3_id

    if ip:
        vm.vde  = True
        vm.ip   = ip
    else:
        vm.vde  = False
        vm.ip   = None

    # save and free up database while launching vms
    d["free_vms"] = free_vms

    running_vms=d["running_vms"]
    running_vms.append(vm)
    d["running_vms"] = running_vms

    closeLockedDb(d)
    return vm

def vm_lookup(id):
    d = openLockedDb(IP_FILE_LOCK, IP_FILE_DICT)
    running_vms = d["running_vms"]
    vm = next((vm for vm in running_vms if vm.vm_id == id), None)

    # make sure we actually found some
    if not vm:
        closeLockedDb(d)
        die("vm " + str(id) + " not running")

    closeLockedDb(d)
    return vm


def vm_cleanup(vmdir):

    idfile = os.path.join(vmdir,"id")
    pidfile = os.path.join(vmdir,"pid")
        
    ids = ""
    try:
        with open(idfile,"r") as f:
            ids = f.read()
    except:
        pass
    
    ids = ids.split("/")
    
    if ids[0] == "":
        die("No ids found in <%s>!" % idfile)
    
    pid = "NONE"
    try:
        pid = readfile(pidfile)
        os.kill(int(pid), signal.SIGKILL)
    except:
        pass

    for id in ids:
        try:
            vm_slot_put(int(id.strip()))
        except:
            pass

    try:
        shutil.rmtree(vmdir)
    except:
        pass


class ClusteredVM(object):
    """Defines a virtual machine object.
    """

    def __init__(self, vm_id, bridge, opts, vms_id, vm_tmpdir, vm_console):
        """Initialize the VM object with its essential data.
        """
        self.idnum    = vm_id
        self.vmsid    = vms_id
        self.idstr    = str(self.idnum)
        self.idhex    = hex(self.idnum+256)[-2:]
        self.bridge   = bridge
        self.ipaddr   = bridge.ipgen(vm_id)
        self.macaddr  = bridge.macgen(vm_id)
        self.name     = "vm%d-%s" % (self.idnum, bridge.name)
        self.tapname  = self.name
        self.thread   = None
        self.status   = "inactive"
        self.tmpdir   = vm_tmpdir
        self.console  = vm_console
        self.opts     = opts

        try:
            os.makedirs(self.tmpdir, 0700)
        except OSError:
            die ("Failed to create tmpdir: "+self.tmpdir)

    def setup(self):
        # Create the tap device owned by the current user
        subprocess.check_call(['sudo', '-n', '--', 'ip', 'tuntap',
                               'add', 'dev', self.tapname,
                               'mode', 'tap',
                               'user', str(os.getuid()),
                               'group', str(os.getgid())])
        subprocess.check_call(['sudo', '-n', '--', 'ip', 'link', 'set', 'dev', self.tapname, 'up'])
        subprocess.check_call(['sudo', '-n', '--', 'brctl', 'addif', self.bridge.name, self.tapname])        

    def run(self):
        opts = self.opts

        # setup run CD:
        if not opts.cdrom:
            self.iso=None
        elif os.path.isdir(opts.cdrom):
            self.iso = os.path.join(self.tmpdir,"run.iso")
            if subprocess.call(["genisoimage", "-quiet", "-R",
                                "-input-charset", "utf-8", "-o",
                                self.iso, opts.cdrom]):
                die("Could not create cdrom from dir: "+opts.cdrom)
        else:
            self.iso = opts.cdrom

        # generates scratch drives:
        self.drives = []
        if opts.scratch:
            sizes = opts.scratch.split(",")
            i = 1;
            for size in sizes:
                if size.strip():
                    name = os.path.join(self.tmpdir,"disk-"+str(i))
                    i += 1
                    if subprocess.call(["fallocate", "-l", size, name]):
                        warning ("Error creating a "+size+" scratch drive with fallocate. Trying dd")
                        if subprocess.call(["dd", "if=/dev/zero", "of="+name, "count=1", "bs="+size]):
                            die ("Error creating a "+size+" scratch drive with dd")
                    self.drives.append(name)

        # build qemu command and start
        cmd = ["qemu-system-x86_64"]
        cmd.extend(["-machine", "accel=kvm"])
        cmd.extend(["-pidfile", os.path.join(self.tmpdir,"pid",)])
        cmd.extend(["-m", opts.mem])
        cmd.extend(["-smp", "%d,sockets=%d" % (int(opts.cpus), int(opts.cpus))])
        if opts.kernel:
            cmd.extend(["-kernel", opts.kernel])
            kernelParams = "console=ttyS0,115200 kgdboc=ttyS2,115200"
            kernelParams += " ip="+self.ipaddr
            if opts.append:
                kernelParams += " "+opts.append
            cmd.extend(["-append", kernelParams])
        if opts.initrd:
            cmd.extend(["-initrd", opts.initrd])
        cmd.extend(["-nographic"])
        cmd.extend(["-serial", self.console])
        cmd.extend(["-serial", "mon:unix:" + os.path.join(self.tmpdir,"con")+",server,nowait"])
        cmd.extend(["-serial", "unix:" + os.path.join(self.tmpdir,"gdb")+",server,nowait"])
        cmd.extend(["-monitor", "unix:" + os.path.join(self.tmpdir,"mon")+",server,nowait"])
        if opts.persistant:
            cmd.extend(["-drive", "format=raw,file="+opts.image])
        else:
            cmd.extend(["-drive", "format=raw,snapshot=on,file="+opts.image])
        if opts.filesystems:
            for fspath, fslabel in opts.filesystems:
                cmd.extend(["-virtfs", "local,path="+fspath+",mount_tag="+fslabel+",security_model=none"])
        for drive in self.drives:  # add scratch drives
            cmd.extend(["-drive", "if=virtio,format=raw,cache=writeback,file="+drive])
        if self.iso:              # add cdrom
            cmd.extend(["-cdrom", self.iso])
        cmd.extend(["-netdev","tap,id=eth0,ifname=%s,script=no,downscript=no" % self.tapname])
        cmd.extend(["-device","virtio-net-pci,netdev=eth0,mac="+self.macaddr])

        self.proc = subprocess.Popen(cmd, shell=False, close_fds=True)

        return self.proc

    def cleanup(self):
        """Cleanup tasks for this vm after it has terminated
        """
        # Take down the tap device.  It is not necessary to down the
        # tap device or remove it from the bridge, that happens
        # automatically.
        subprocess.check_call(['sudo','-n', '--', 'ip', 'tuntap', 'del', 'dev', self.tapname, 'mode', 'tap'])


class Cluster(object):
    """Defines a cluster of VMs attachd to a single virtual bridge.
    """

    def __init__(self, num_of_vms, opts):
        """Initialize the cluster object with bridge information.
        """

        bridge = bridge_get()

        self.idnum    = bridge.br_num               # int version of id
        self.br_key   = bridge.br_key               # key of bridge
        self.idstr    = str(self.idnum)             # str version of id
        self.idhex    = hex(self.idnum+256)[-2:]    # hex version of id
        self.name     = "vmbr%s" % self.idstr       # bridge name
        self.vms      = []                          # list of vms in cluster

        self.owner    = getpass.getuser()           # who "owns" this cluster

        # IPv4 parameters
        self.ipaddr   = self.ipgen(1)               # bridge ip addresss
        self.ipnet    = self.ipgen(0)               # vm network base addresss
        self.cidr     = 24                          # CIDR mask (netmask)

        # IPv6 parameters
        self.ipv6addr = self.ipv6gen(1)             # bridge IPv6 address
        self.ipv6net  = self.ipv6gen(0)             # IPv6 network
        self.v6cidr   = 64                          # IPv6 CIDR (netmask)

        self.status   = "inactive"                  # cluster status
        self.tmpdir   = opts.tmpdir

        # Set the dnsmasq file attributes and wipe the files
        for dnattr in ["conf", "pid", "leases", "hostsfile", "addnhosts", "output"]:
            dnfile=os.path.join(self.tmpdir, "%s.dnsmasq.%s" % (self.name, dnattr))
            setattr(self, "dnsmasq_%s" % dnattr, dnfile)
            open(dnfile, 'w').close() # Truncate/create

        slotfile = os.path.join(self.tmpdir,'id')
        if os.path.exists(slotfile):
            os.remove(slotfile)

        if opts.indexfile:
            if os.path.exists(opts.indexfile):
                os.remove(opts.indexfile)

        # for each VM, grab a VM object and add it to cluster's VM list
        for vm in range(num_of_vms):

            vm_name = "vm%d-%s" % (vm+2, self.name)

            vm_tmpdir = os.path.join(self.tmpdir,
                vm_name+"-"+self.owner)

            slot = vm_slot_get(vm_tmpdir, self.ipgen(vm+2), opts.conx3)

            appendfile(slotfile, slot.vm_id)
            if opts.indexfile:
                appendfile(opts.indexfile, slot.vm_id)

            if vm == 0:
                vm_console = opts.console
            else:
                vm_console = 'file:%s' % os.path.join(vm_tmpdir, "console")

            self.vms.append(ClusteredVM(vm+2, self, opts, slot, vm_tmpdir, vm_console))


    # Network address generators indexed off node number for the MAC address,
    # IPv4 and IPv6 addresses.
    def macgen(self, node):
        return "de:ad:be:ef:%s:%s" % (self.idhex, hex(node+256)[-2:])

    def ipgen(self, node):
        return "172.30.%d.%d" % (self.idnum, node)

    def ipv6gen(self, node):
        return "fd84:c772:8103:fa%s::%s" % (self.idhex, hex(node+256)[-2:])


    def enable_dnsmasq(self):
        """Configure and start dnsmasq
        
        IPv4 will have explicit host entries (hostsfile).

        IPv6 will use router advertisement to pick a random address
        due to the difficulty of determining the DUID-LT in advance.
        """
        with open(self.dnsmasq_conf, "w") as f:
            f.write("strict-order\n")
            f.write("domain-needed\n")
            f.write("domain=%s\n" % self.name)
            f.write("expand-hosts\n")
            f.write("local=/%s/\n" % self.name)
            f.write("pid-file=%s\n" % self.dnsmasq_pid)
            f.write("except-interface=lo\n")
            f.write("bind-dynamic\n")
            f.write("interface=%s\n" % self.name)
            f.write("dhcp-range=%s,%s\n" % (self.ipgen(128), self.ipgen(254)))
            f.write("dhcp-no-override\n")
            f.write("dhcp-range=%s,constructor:%s,slaac,ra-names,%d\n" % (self.ipv6gen(1), self.name, self.v6cidr))
            f.write("dhcp-leasefile=%s\n" % self.dnsmasq_leases)
            f.write("dhcp-lease-max=383\n")
            f.write("dhcp-hostsfile=%s\n" % self.dnsmasq_hostsfile)
            f.write("addn-hosts=%s\n" % self.dnsmasq_addnhosts)

        with open(self.dnsmasq_hostsfile, "w") as f:
            for idx in range(2, 127):
                f.write("%s,%s,node%d\n" % (self.macgen(idx), self.ipgen(idx), idx-1))

        cmd = ['sudo', '-n', '--', 'dnsmasq',
               "--log-facility=-", '--log-queries',
               "--conf-file=%s" % self.dnsmasq_conf, 
               "--user=%s" % self.owner]
        subprocess.check_call(cmd, shell=False, close_fds=True,
                              stdin=open(os.devnull, 'r'),
                              stdout=open(self.dnsmasq_output, 'w'),
                              stderr=subprocess.STDOUT)

    def disable_dnsmasq(self):
        try:
            with open(self.dnsmasq_pid, 'r') as f:
                pid=int(f.read().strip())
                os.kill(pid, signal.SIGTERM)
        except:
            warning("Failed to terminate dnsmasq")

    def enable_bridge(self):
        """Enable the bridge using bridge control commands.
        """
        try:
            subprocess.check_call(['sudo', '-n', '--', 'brctl', 'addbr', self.name])
            subprocess.check_call(['sudo', '-n', '--', 'brctl', 'stp', self.name, 'on'])
            subprocess.check_call(['sudo', '-n', '--', 'brctl', 'setfd', self.name, '2'])
            subprocess.check_call(['sudo', '-n', '--', 'brctl', 'sethello', self.name, '2'])
            subprocess.check_call(['sudo', '-n', '--', 'ip', 'tuntap','add', 'dev', self.name + "-host", 'mode', 'tap'])
            subprocess.check_call(['sudo', '-n', '--', 'brctl', 'addif', self.name, self.name + "-host"])
            subprocess.check_call(['sudo', '-n', '--', 'sysctl', '-q', '-w', "net.ipv6.conf.%s.accept_ra=0" % self.name, "net.ipv6.conf.%s.autoconf=0" % self.name])
            subprocess.check_call(['sudo', '-n', '--', 'ip', 'link', 'set', 'dev', self.name, 'up'])
            subprocess.check_call(['sudo', '-n', '--', 'ip', 'addr', 'add', "%s/%d" %(self.ipaddr, self.cidr), "dev", self.name])
            subprocess.check_call(['sudo', '-n', '--', 'ip', 'addr', 'add', "%s/%d" %(self.ipv6addr, self.v6cidr), "dev", self.name])

            # NAT IPv4 packets off the bridge if supported.  The iptables
            # configuration depends on iptables on the server not being
            # used for anything else.
            subprocess.call(['sudo', '-n', '--', 'sysctl', '-q', '-w', 'net.ipv4.ip_forward=1'])
            subprocess.call(['sudo', '-n', '--', 'iptables', '-t', 'nat', '-I', 'POSTROUTING', '-s', "%s/%d" % (self.ipnet, self.cidr), '!', '-o', self.name, '-j', 'MASQUERADE'])
            subprocess.call(['sudo', '-n', '--', 'iptables', '-t', 'filter', '-I', 'INPUT', '-i', self.name, '-j', 'ACCEPT'])
            subprocess.call(['sudo', '-n', '--', 'iptables', '-t', 'filter', '-I', 'OUTPUT', '-o', self.name, '-j', 'ACCEPT'])
            subprocess.call(['sudo', '-n', '--', 'iptables', '-t', 'filter', '-I', 'FORWARD', '-i', self.name, '-j', 'ACCEPT'])
            subprocess.call(['sudo', '-n', '--', 'iptables', '-t', 'filter', '-I', 'FORWARD', '-o', self.name, '-j', 'ACCEPT'])

            self.status = "enabled"
        except:
            die("Unable to enable bridge <%s>" % self.name)

    def disable_bridge(self):
        """Disable the bridge using bridge control commands.
        """
        # Note, we will leave ip forwarding enabled since there
        # may be other bridges using it.
        subprocess.call(['sudo', '-n', '--', 'iptables', '-t', 'nat', '-D', 'POSTROUTING', '-s', "%s/%d" % (self.ipnet, self.cidr), '!', '-o', self.name, '-j', 'MASQUERADE'])
        subprocess.call(['sudo', '-n', '--', 'iptables', '-t', 'filter', '-D', 'INPUT', '-i', self.name, '-j', 'ACCEPT'])
        subprocess.call(['sudo', '-n', '--', 'iptables', '-t', 'filter', '-D', 'OUTPUT', '-o', self.name, '-j', 'ACCEPT'])
        subprocess.call(['sudo', '-n', '--', 'iptables', '-t', 'filter', '-D', 'FORWARD', '-i', self.name, '-j', 'ACCEPT'])
        subprocess.call(['sudo', '-n', '--', 'iptables', '-t', 'filter', '-D', 'FORWARD', '-o', self.name, '-j', 'ACCEPT'])

        subprocess.call(['sudo', '-n', '--', 'ip', 'link', 'set', 'dev', self.name, 'down'])

        subprocess.call(['sudo', '-n', '--', 'ip', 'tuntap','del', 'dev', self.name + "-host", 'mode', 'tap'])

        subprocess.check_call(['sudo', '-n', '--', 'brctl', 'delbr', self.name])

        bridge_free(self.br_key)

        self.owner = None
        self.status = "disabled"


    # Tear down VMs and networking on a signal or abort
    def terminate_vms(self):
        for vm in self.vms:
            try:
                vm.proc.terminate()
            except:
                pass

    def run(self):
        """Setup and run the cluster.
        """
        for sig in (signal.SIGHUP, signal.SIGINT, signal.SIGQUIT, signal.SIGILL,
                    signal.SIGABRT, signal.SIGFPE, signal.SIGPIPE, signal.SIGTERM,
                    signal.SIGUSR1, signal.SIGUSR2):
            signal.signal(sig, lambda sig, frame: self.terminate_vms())

        # enable the bridge
        self.enable_bridge()

        # Setup dnsmasq on the bridge
        self.enable_dnsmasq()

        # Launch the VMs
        for vm in self.vms:
            vm.setup()
            vm.run()

        # Collect VMs as they finish
        while True:
            for vm in self.vms:
                vm.proc.poll()

            for vm in self.vms:
                if vm.proc.returncode == None:
                    break # Re-poll
            else:
                break # Abort the poll loop
            time.sleep(0.5)

        # Cleanup after the VMs
        for vm in self.vms:
            attempts=0
            while True:
                try:
                    vm.cleanup()
                    break
                except Exception, e:
                    attempts+=1
                    if attempts > 10:
                        warning("Failed to clean up VM %d" % vm.idnum)
                        break
                    else:
                        time.sleep(0.5)

        for vm in self.vms:
            try:
                vm_slot_put(vm.vmsid)
            except:
                warning("Failed to return the slot for %d" % vm.vmsid)

        # terminate dnsmasq
        self.disable_dnsmasq()

        # disable the bridge
        self.disable_bridge()

def cmd_start():
    """Start new virtual machines
    """
    opt = OptionParser("Usage: %prog start [options] [number]",
        description="Start a virtual machine or cluster")

    opt.add_option("-i", "--image", dest="image",
        help="boot image of the virtual machine(s)")

    opt.add_option("-k", "--kernel", dest="kernel",
        help="kernel used to boot the virtual machine(s)")

    opt.add_option("-r", "--initrd", dest="initrd",
        help="initial ramdisk for boot")

    opt.add_option("-a", "--append", dest="append",
        default="root=/dev/sda rw",
        help="append kernel command line boot arguments")

    opt.add_option("-c", "--cdrom-source", dest="cdrom",
        help="cdrom image or directory to convert into a cdrom image")

    opt.add_option("-s", "--scratch-dev ", dest="scratch",
        default="",
        help="list of scratch device sizes. ex: 256M,2G")

    opt.add_option("-t", "--tmpfs-dir", dest="tmpfs",
        default=DEFAULT_TMP,
        help="location of the tmpfs directory for scratch devices")

    opt.add_option("-m", "--memory", dest="mem",
        default=DEFAULT_MEMORY,
        help="amount of memory to be allocated per VM")

    opt.add_option("-C", "--core", dest="core",
        default=None,
        help="file used for log and core")

    opt.add_option("--cpus", dest="cpus",
        default="1",
        help="number of CPUs allocated per VM")

    opt.add_option("-p", "--persistant", dest="persistant",
        action="store_true",
        help="use writeback")


    opt.add_option("--fs", dest="filesystems",
        action="append", nargs=2,
        help="mount a directory (first argument) as " +
        "a filesystem label (second argument) in the VM")

    opt.add_option("--id", dest="indexfile",
        help="file to write vm number to")

    opt.add_option("--console", dest="console",
        default="stdio",
        help="where to attach the vm console (ex: stdio, file:foo)")

    opt.add_option("--conx3", dest="conx3",
        default=False, action="store_true",
        help="assign a virtual pci connect x3 nic for rdma")

    opt.add_option("--cluster", dest="cluster",
        help="Start a cluster with the specified number of nodes")

    (options, args) = opt.parse_args()

    tmpdate = datetime.datetime.strftime(
        datetime.datetime.today(),"%Y%m%d-%H%M%S")
    
    options.tmpdir = os.path.join(
        options.tmpfs,"vm-%s-%s" % (tmpdate, randstr()))

    # generate tmp dir
    try:
        os.makedirs(options.tmpdir, 0700)
    except OSError:
        die ("Failed to create tmpdir: "+options.tmpdir)
        
    if options.cluster:
        
        cluster = Cluster(int(options.cluster),options)

        cluster.run()

    else:

        # path for single vm

        if not options.image:
            die ("Requires an image to boot")

        if not os.path.isfile(options.image):
            die("Cannot find base image file: "+options.image)

        #if not options.kernel:

        if options.kernel and not os.path.isfile(options.kernel):
            die("Cannot find kernel file: "+options.kernel)

        if options.initrd and not os.path.isfile(options.initrd):
            die("Cannot find initrd file: "+options.initrd)

        try:
            caught_signal = False

            def sighandler(signum, stack):
                if not caught_signal:
                    caught_signal = True
                    raise Exception("signal caught")

            for i in [x for x in dir(signal) if x.startswith("SIG")]:
                if i in ['SIGHUP', 'SIGINT', 'SIGQUIT', 'SIGILL', 'SIGABRT',
                    'SIGFPE', 'SIGSEGV', 'SIGPIPE', 'SIGALRM', 'SIGTERM',
                    'SIGUSR1', 'SIGUSR2']:
                    signum = getattr(signal, i)
                    signal.signal(signum, sighandler)

            vm = vm_slot_get(options.tmpdir, None, options.conx3)

            idfile = os.path.join(options.tmpdir,'id')

            writefile(idfile, vm.vm_id)
            if options.indexfile:
                writefile(options.indexfile, vm.vm_id)

            # setup run CD:
            if not options.cdrom:
                iso=None
            elif os.path.isdir(options.cdrom):
                iso = options.tmpdir + "/run.iso"
                if subprocess.call(["genisoimage", "-quiet", "-R",
                    "-input-charset",
                    "utf-8", "-o", iso, options.cdrom]):
                    die("Could not create cdrom from dir: "+options.cdrom)
            else:
                iso=options.cdrom

             # generates scratch drives:
            drives = []
            if options.scratch:
                sizes = options.scratch.split(",")

                i = 1;
                for size in sizes:
                    if size.strip():
                        name = options.tmpdir + "/disk-" + str(i)
                        i += 1

                        if subprocess.call(["fallocate", "-l", size, name]):
                            warning("fallocate error, trying dd")
                            if subprocess.call(["dd", "if=/dev/zero", "of="+name,
                                "count=1", "bs="+size]):
                               die ("error creating scratch drive '"+name+"'")
                        drives.append(name)

            # generate log and core dump device
            if options.core:
                (name,size) = options.core.split(",")
                if size==None:
                    size="10G"
                if subprocess.call(["fallocate", "-l", size, name]):
                    warning("fallocate error, trying dd")
                    if subprocess.call(["dd", "if=/dev/zero", "of="+name,
                                        "count=1", "bs="+size]):
                        die ("error creating core/log drive '"+name+"'")
                if subprocess.call(["mkfs.ext4", "-U","11111111-2222-3333-4444-555555555555","-F",name]):
                    die("mkfs.ext4 failed on '"+name+"'")


            # build qemu command and start
            cmd = ["qemu-system-x86_64"]
            cmd.extend(["-machine", "accel=kvm"])
            cmd.extend(["-pidfile", options.tmpdir + "/pid"])
            cmd.extend(["-m", options.mem])
            cmd.extend(["-smp", "%d,sockets=%d" % (int(options.cpus), int(options.cpus))])

            if options.kernel:
                cmd.extend(["-kernel", options.kernel])
                kernelParams = "console=ttyS0,115200 kgdboc=ttyS2,115200"
                if options.append:
                    kernelParams += " "+options.append
                cmd.extend(["-append", kernelParams])

            if options.initrd:
                cmd.extend(["-initrd", options.initrd])

            cmd.extend(["-nographic"])
            cmd.extend(["-serial",  options.console])
            cmd.extend(["-serial",  "mon:unix:" + options.tmpdir + "/con,server,nowait"])
            cmd.extend(["-serial",  "unix:" + options.tmpdir + "/kgdb,server,nowait"])
            cmd.extend(["-monitor", "unix:" + options.tmpdir + "/mon,server,nowait"])
            cmd.extend(["-gdb", "unix:" + options.tmpdir + "/gdb,server,nowait"])
    
            # Drives:
            if options.persistant:
                cmd.extend(["-drive", "format=raw,file="+options.image])
            else:
                cmd.extend(["-drive", "format=raw,snapshot=on,file="+options.image])
            if options.filesystems:
                for fspath, fslabel in options.filesystems:
                    cmd.extend(["-virtfs", "local,path="+fspath+",mount_tag="+fslabel+",security_model=none"])
            if options.core:
               cmd.extend(["-drive", "format=raw,file="+options.core.split(",")[0]])

            for drive in drives:  # add scratch drives
                cmd.extend(["-drive", "if=virtio,format=raw,cache=writeback,file="+drive])

            if iso:              # add cdrom
                cmd.extend(["-cdrom",iso])
 
            cmd.extend(["-net", "nic,model=virtio"])
            cmd.extend(["-net", "user,host=10.0.2.2,restrict=off,hostfwd=tcp:127.0.0.1:" + str(vm.vm_id + 9000) + "-:22"])
    
            if options.conx3:
                print "Assigning vf: ", vm.conx3_id
                cmd.extend(["-device", "pci-assign,host="+str(vm.conx3_id)])
        
            warning("Executing: "+str(cmd))
            
            p = subprocess.Popen(cmd, shell=False)

            vm.pid = p.pid
            vm.status="running"
            print GREEN+"Vm ID: "+str(vm.vm_id)+NC
    
            p.wait()
        except:
            pass
    
    vm_cleanup(options.tmpdir)
    subprocess.call(["stty", "sane"])

def cmd_stop():
    """Stop virtual machines by id or ipaddr
    """

    opt = OptionParser("Usage: %prog stop [options] [id]",
        description="Stop a vm by its id or its ip address")

    opt.add_option("-i", "--ip", dest="ipaddr",
      help="The ip address of the vm")

    (opts, args) = opt.parse_args()

    if opts.ipaddr:
        os.system(
          "ssh -o StrictHostKeyChecking=no -i id_dsa %s 'shutdown -h now'"
          % opts.ipaddr)
    else:

        if len(args) == 0:
            die("Please provide a vm id or ip address to stop")

        ids = args[0].split("/") 
        
        print ids       
        
        for id in ids:
            vm = vm_lookup(int(id))
            pid = readfile(vm.tmpdir + '/pid')
            os.kill(int(pid), signal.SIGKILL)


def cmd_ssh():
    """ssh into a virtual machine"""

    if len(sys.argv) <= 1:
        die("Please provide a vm id to SSH to")

    id = int(sys.argv[1].split('/')[0])
    vm = vm_lookup(id)

    keyfile = os.path.dirname(os.path.realpath(__file__)) + "/id_dsa"
    os.system("chmod 600 " + keyfile)

    if vm.vde:
        cmd = ["ssh", "-o", "StrictHostKeyChecking=no", "-o",
            "UserKnownHostsFile=/dev/null", "-i", keyfile, "root@"+vm.ip]
    else:
        cmd = ["ssh", "-o", "NoHostAuthenticationForLocalhost=yes",
            "-i", keyfile, "-p", str(9000 + id), "root@127.0.0.1"]

    cmd.extend(sys.argv[2:])
    os.execvp("ssh", cmd)


def vm_gdb(gdbsocket):
    if len(sys.argv) <= 2:
        die("Please provide a vm ID and a vmlinux file")

    vm = vm_lookup(int(sys.argv[1]))
    os.execlp("gdb", "gdb",
          "-ex", "set remote interrupt-on-connect",
          "-ex", "target remote | socat UNIX-CONNECT:" +
          os.path.join(vm.tmpdir, gdbsocket) + ' -', sys.argv[2])


def cmd_gdb():
    vm_gdb('gdb')


def cmd_kgdb():
    vm_gdb('kgdb')


def cmd_mon():
    if len(sys.argv)<=1:
        die("Please provide a vm id")

    vm = vm_lookup(int(sys.argv[1]))

    os.execlp("minicom", "minicom",
          "-D", "unix#" + vm.tmpdir + "mon")

def cmd_ls():
    return cmd_list()

def cmd_list():
    """List out running VMs"""
    opt=OptionParser("usage: %prog vm list [session_id]",
             description="""List out running VMs""")
    (options, args) = opt.parse_args()

    if len(args) == 0 or args[0] == "vms":
        
        # get running vms:
        d = openLockedDb(IP_FILE_LOCK, IP_FILE_DICT)
        running_vms = d["running_vms"]
        closeLockedDb(d)
    
        running_vms = sorted(running_vms, key=operator.attrgetter("owner", "vm_id"))
    
        print "Domain\tIP\t\tConX3 id\tOwner\tDead"
        print "------\t------------\t--------\t-----\t----"
    
        for vm in running_vms:
            mia=" " if vm.exists() == True else "X"
            print (str(vm.name) + "\t" + str(vm.ip) + "\t" +
                str(vm.conx3_id) + "\t\t" +
                str(vm.owner) + "\t" + mia)

    elif args[0] == "bridges":
        d = openLockedDb(BR_FILE_LOCK, BR_FILE_DICT)
        bridges = d["bridges"]
        closeLockedDb(d)

        bridges = bridges.values()
       
        bridges = sorted(bridges, key=operator.attrgetter("br_name"))
        print "Bridge\tAvailable?"
        print "------\t----------"
        for br in bridges:
            print br.br_name+"\t"+str(br.available)
    

def gendbs(dbname, description, lockfile, dbfile, callback):
    """Generic function to generate database files (union of duplicated code).

    cmdname       Name of the database being created (ips, bridges)
    description   Help text
    lockfile      Name of the lockfile to be created
    dbfile        Name of the database file to be created
    callback      callable object to populate the database
                  (passed an open shelve object as its argument)
    """
    opt=OptionParser("usage: %prog vm gen" + dbname,
                     description=description)
    opt.add_option("-s", "--safe", dest="safe",
                   default=False, action="store_true",
                   help="Automatic, but only if the lock and dbfile do not exist")
    opt.add_option("-f", "--force", dest="force",
                   default=False, action="store_true",
                   help="Automatic, force overwrite")
    (options, args) = opt.parse_args()

    if options.force and options.safe:
        die("--safe and --force are mutually exclusive")

    if os.geteuid() != 0:
        die("Root permissions are required")

    if not (options.force or options.safe):
        check = raw_input("This will overwrite any current %s database files. Are you sure? (y): " % dbname)
        if check != "y":
            sys.exit(0)

    # make directory
    try:
        os.mkdir("/etc/vms")
    except OSError as e:
        if e.errno != errno.EEXIST:
            die("Failed to create /etc/vms")

    lockFD = os.open(lockfile, os.O_RDWR | os.O_CREAT)
    try:
        if options.safe:
            fcntl.flock(lockFD, fcntl.LOCK_EX)
            if os.path.exists(dbfile):
                print "Already setup"
                return

        os.fchmod(lockFD, 0666)
        os.lseek(lockFD, 0, os.SEEK_SET)
        os.ftruncate(lockFD, 0)
        os.write(lockFD, "used for locking access to %s database file" % dbname)

        db = shelve.open(dbfile)
        db["sess_id"]=1000

        callback(db)

        db.close()
        os.chmod(dbfile, 0666)

        print "Setup completed"

    finally:
        # This will implicitly release the lock
        os.close(lockFD)


def cmd_genips():
    """
    Generates a new set of new IP Macaddress combinations for
    and puts them in the proper locations:
    Vm.ips-dict - shelve dictionary used by python

    For use when setting up networking on a new machine, or if
    any of the config files get screwed up.
    """

    def ips_generator(d):
        free_vms = []

        for i in range (0, 100):
            #generate IP file
            vm_num = str(i).zfill(2)
            name = "vm"+vm_num
            ip = "172.20.0."+str(i+100)
            mac = "DE:AD:BE:EF:01:"+vm_num

            #generate ips dict
            vm = Domain(i, ip, mac)
            free_vms.insert(0, vm)

        d["free_vms"] = free_vms
        d["running_vms"] = []

    gendbs("ips", "Generate a new IP/MAC file", IP_FILE_LOCK, IP_FILE_DICT, ips_generator)


def cmd_genbridges():
    """
    Generates a new set of bridges

    For use when setting up networking on a new machine, or if
    any of the config files get screwed up.
    """

    def bridges_generator(db):
        bridges = {}

        for br_num in range (1,10):
            #generate bridge file
            br_key = str(br_num)
            br_name = "br"+br_key
            bridges[br_key] = Bridge(br_key,br_num,br_name)

        db["bridges"] = bridges

    gendbs("bridges", "Generate a new bridge file", BR_FILE_LOCK, BR_FILE_DICT, bridges_generator)


def cmd_genconx3():
    """
    Generates a new set of detached virtual Mellanox X3 card
    provided the machine has one. Updates the existing database.
    Your vm can use rdma functionality with this card.
    """

    p = subprocess.Popen(['lspci', '-vvv'], bufsize=-1, stdout=subprocess.PIPE)
    flag = 0
    phys_dev = ""
    for line in p.stdout:
        if flag == 0:
            if re.search("Mellanox", line):
                entries = re.split('\W+', line)
                searchStr = entries[0] + ':0'
                phys_dev = entries[0] + ':' + entries[1] + '.' + entries[2]
                print phys_dev
                flag = 1
        if flag == 1:
            if re.search("Number of VFs:", line):
                entries = re.split(',', line)
                entry = re.split(':', entries[0])
                num_vfs='num_vfs=' + str(int(entry[1]))
                entry = re.split(':', entries[1])
                probe_vf='probe_vf=' + str(int(entry[1]))
                entry = re.split(':', entries[2])
            # Number of VFs: 0
            if int(entry[1]) == 0:
                print "SR-IOV is not yet enabled!"
                subprocess.call(['rmmod', 'mlx4_ib', 'mlx4_core'])
                print num_vfs + ' ' + probe_vf
                subprocess.call(['modprobe', '-v', 'mlx4_core', num_vfs, probe_vf])
            else:
                print "SR-IOV enabled!"
            break
    p.kill()
    p.wait()

    if flag == 1:
        d = shelve.open(CX3_FILE_DICT)
        free_conx3 = []
        lock = open(CX3_FILE_LOCK, "w")
        lock.write("used for locking access to pci connect x3 nic database file")
        p = subprocess.Popen(['lspci', '-n'], bufsize=-1, stdout=subprocess.PIPE)
        flag = 0
        for line in p.stdout:
            m = re.match(searchStr, line)
            if m:
                entries = re.split(' ', line)
                #entries[0] is the vf id
                #entries[2] is the vendor and the device id
                if not re.match(phys_dev, entries[0]):
                    if flag == 0:
                        entry = re.split('[:\n]', entries[2])
                        vend_dev_id = entry[0] + ' ' + entry[1]
                        f = open('/sys/bus/pci/drivers/pci-stub/new_id', 'w')
                        f.write(vend_dev_id)
                        f.close()
                        flag = 1
                    fn = '/sys/bus/pci/devices/0000:' + entries[0] + '/driver/unbind'
                    devid = '0000:' + entries[0]
                    f = open(fn, 'w')
                    f.write(devid)
                    f.close()
                    f = open('/sys/bus/pci/drivers/pci-stub/bind', 'w')
                    f.write(devid)
                    f.close()
                    # populate the connect x3 pci cards db with these devids
                    free_conx3.append(entries[0])
                    d["free_conx3"] = free_conx3
                    print d["free_conx3"]
        d["free_conx3"] = free_conx3
        d.close()
        lock.close()
        p.kill()
        p.wait()


def cmd_help():
    """Print help for commands."""
    print """Usage: vm-start [command] [args]

  Commands:
    start       setup and start a vm or a vm cluster
    stop        stop a vm by id or, for a cluster,
                all vms or a single by name
    ssh         ssh to a virtual machine by id
    gdb         connect to gbd
    kgdb        connect to kgdb
    mon         connect to the qemu monitor
    list        list all running vms
    genips      generate a fresh vm database
    genconx3    update db with virtual rdma capable nic
    genbridges  generate a fresh bridges database
    help        print help for commands
    """

"""Main program."""

# if there is no command or args, print error message
if len(sys.argv) == 1:
    cmd_help()
    die("Please provide a command and appropriate arguments.")

# if first arg is a help option or command, print help and exit
if sys.argv[1] in ["-h", "--help", "help"]:
    cmd_help()
    sys.exit(0)

# try to find the command in the global namespace
try:
    _cmd_name = "cmd_" + sys.argv[1]
    _cmd_func = getattr(sys.modules[__name__], _cmd_name)
except AttributeError:
    die("<%s> is not a valid command.\n" % sys.argv[1] +
      "Try 'vm-cluster help' for more info.")

# remove the command from argv and execute the command function
sys.argv.pop(1)
_cmd_func()
