#!/usr/bin/python
# Copyright (c) 2013 Datera, Inc. All rights reserved
# Datera, Inc. Confidential and Propriatory

import getpass
import sys
import os
import errno
import fcntl
import subprocess
import shelve
import shutil
import signal
import operator
import time
import string
import random
import re
import datetime
import logging
import traceback

from optparse import OptionParser, OptionGroup

# script directory and path
DIR=os.path.dirname(__file__)       # path to script directory

MAX_VMS = 100                       # Max number of VMs. Currently this is pretty arbitrary.
MAX_BRIDGES = 100

# global info file settings:
IP_FILE = "/etc/vms/ips"
IP_FILE_LOCK = IP_FILE+".lock"      # File to lock access to VM list
IP_FILE_DICT = IP_FILE+".dict"      # Shelf file to store vm list

# Locate available ConnectX-3 virtual interfaces
CX3_PCI_STUB_DIR="/sys/bus/pci/drivers/pci-stub"
CX3_VENDOR_IDS = [ 0x15b3 ]
CX3_DEVICE_IDS = [ 0x1004 ]

BR_FILE = "/etc/vms/bridges"
BR_FILE_LOCK = BR_FILE+".lock"      # File to lock access to bridge info
BR_FILE_DICT = BR_FILE+".dict"      # Shelf file to store bridge info

DEFAULT_MEMORY = "1G"               # how much memory to give the vms
DEFAULT_TMP = "/tmp"                # default directory for tmps
DEFAULT_TIMEOUT = 10*60             # timeout: 10 mins

# colors:
GREEN='\033[32m'
CYAN='\033[36m'
NC='\033[0m'

FNULL=open(os.devnull, 'rw'),

def randstr(size=8, chars=string.letters + string.digits):
    return "".join(random.choice(chars) for x in range(size))

def readfile(filename):
    with open(filename, 'r') as f:
        line = f.readline()
    return line

def writefile(filename, line):
    logging.debug("in writefile - writing <%s> into %s" % (line,filename))
    with open(filename, 'w') as f:
        f.write(str(line)+"\n")

def appendfile(filename, line):
    newline = ""
    if os.path.exists(filename):
        with open(filename, 'r') as f:
            newline = f.read()
            newline = newline.strip()
            newline += "/"
                   
    newline += str(line)
    logging.debug("in appendfile - writing <%s> into %s" % (newline,filename))
    with open(filename, 'w') as f:
        f.write(newline+"\n")  

"""
Functions of opening shelf to lock while
reading and writing to shelf file
"""
def openLockedDb(file_lock, file_dict):
    lockFD = os.open(file_lock, os.O_RDONLY)
    fcntl.flock(lockFD, fcntl.LOCK_EX)
    db = shelve.open(file_dict)
    db.lockFD = lockFD
    return db

def closeLockedDb(db):
    db.close()
    fcntl.flock(db.lockFD, fcntl.LOCK_UN)
    os.close(db.lockFD)

class Bridge:
    """Represents a single bridge"""
    def __init__ (self, br_key, br_num, br_name):
        self.br_key = br_key       # string bridge key
        self.br_num = br_num       # integer bridge number
        self.br_name = br_name     # bridge name
        self.available = True      # available?

class Domain:
    """Represents a single virtual machine"""
    def __init__ (self, vm_id):
        self.vm_id = vm_id         # id number for this vm
        self.ip = None               # ip address
        self.mac = None             # mac addresss
        self.owner = None          # who started this machine
        self.name = "vm"+str(vm_id)   # name of the vm, can be custom
        self.tmpdir  = None        # the location of dir to store scratch drives
        self.conx3_id = None       # dev id of the virtual pci x3 Connect X3 card

    def exists(self):
        """Does the VM this represents actually exist?"""
        try:
            with open(self.tmpdir + "/pid", 'r') as f:
                pid=int(f.read().strip())
                expath = os.path.basename(os.readlink("/proc/%d/exe" % pid))
                if expath[:11] == "qemu-system":
                    return True
        except (OSError, IOError, ValueError) as e:
            pass

        return False

def bridge_free(br_key):
    db = openLockedDb(BR_FILE_LOCK, BR_FILE_DICT)
    bridges = db["bridges"]

    bridges[br_key].available = True

    db["bridges"] = bridges
    closeLockedDb(db)
    
def bridge_get():
    db = openLockedDb(BR_FILE_LOCK, BR_FILE_DICT)
    bridges = db["bridges"]

    keys = bridges.keys()
    keys.sort()
    
    bridge = None
    for key in keys:
        if bridges[key].available:
            bridge = bridges[key]
            bridge.available = False
            bridges[key] = bridge
            break
    else:
        raise RuntimeError("No bridge entries available to start cluster")        

    db["bridges"] = bridges
    closeLockedDb(db)
    return bridge

def vm_slot_put(id):
    d = openLockedDb(IP_FILE_LOCK, IP_FILE_DICT)
    running_vms = d["running_vms"]
    vm = next((vm for vm in running_vms if vm.vm_id == id), None)

    if not vm:
        closeLockedDb(d)
        return

    running_vms.remove(vm)
    d["running_vms"] = running_vms

    closeLockedDb(d)

def vm_slot_get(tmpdir, ip, conx3):
    try:
        user = os.environ["SUDO_USER"]
    except KeyError:
        user = os.environ["USER"]

    #load database:
    d = openLockedDb(IP_FILE_LOCK, IP_FILE_DICT)
    running_vms=d["running_vms"]

    # check to make sure we have a free vm entry
    free_vmids=range(MAX_VMS)
    for vm in running_vms:
        try:
            free_vmids.remove(vm.vm_id)
        except ValueError:
            pass

    if len(free_vmids) == 0:
        closeLockedDb(d)
        raise RuntimeError("No vm entries available to start a vm")

    if conx3:
        cards = list_conx3()
        logging.debug("CX3 cards detected: %s" % ' '.join(cards))
        for vm in running_vms:
            if vm.conx3_id in cards:
                cards.remove(vm.conx3_id)
        if len(cards) == 0:
            raise RuntimeError("ConnectX3 was requested but none available")
        logging.debug("Assigning CX3 card %s" % cards[0])
        conx3_id = cards[0]
    else:
        conx3_id = None


    # get vm entr, mark for setup
    vm = Domain(free_vmids[0])
    vm.state    = "setup"
    vm.owner    = user
    vm.tmpdir   = tmpdir
    vm.conx3_id = conx3_id
    vm.ip       = ip

    running_vms.append(vm)
    d["running_vms"] = running_vms

    closeLockedDb(d)
    return vm

def vm_lookup(id):
    d = openLockedDb(IP_FILE_LOCK, IP_FILE_DICT)
    running_vms = d["running_vms"]
    vm = next((vm for vm in running_vms if vm.vm_id == id), None)

    # make sure we actually found some
    if not vm:
        closeLockedDb(d)
        raise RuntimeError("vm " + str(id) + " not running")

    closeLockedDb(d)
    return vm


def vm_cleanup(vmdir):

    idfile = os.path.join(vmdir,"id")
    pidfile = os.path.join(vmdir,"pid")
        
    ids = ""
    try:
        with open(idfile,"r") as f:
            ids = f.read()
    except:
        pass
    
    ids = ids.split("/")
    
    if ids[0] == "":
        raise RuntimeError("No ids found in <%s>!" % idfile)
    
    pid = "NONE"
    try:
        pid = readfile(pidfile)
        os.kill(int(pid), signal.SIGKILL)
    except:
        pass

    for id in ids:
        try:
            vm_slot_put(int(id.strip()))
        except:
            pass

    try:
        shutil.rmtree(vmdir)
    except:
        pass


class ClusteredVM(object):
    """Defines a virtual machine object.
    """

    def __init__(self, vm_id, bridge, opts, vms_id, vm_tmpdir, vm_console):
        """Initialize the VM object with its essential data.
        """
        self.idnum    = vm_id
        self.vmsid    = vms_id
        self.idstr    = str(self.idnum)
        self.idhex    = hex(self.idnum+256)[-2:]
        self.bridge   = bridge
        self.ipaddr   = bridge.ipgen(vm_id)
        self.macaddr  = bridge.macgen(vm_id)
        self.name     = "vm%d-%s" % (self.idnum, bridge.name)
        self.tapname  = self.name
        self.thread   = None
        self.status   = "inactive"
        self.tmpdir   = vm_tmpdir
        self.console  = vm_console
        self.opts     = opts

        os.makedirs(self.tmpdir, 0700)

    def setup(self):
        # Create the tap device owned by the current user
        subprocess.check_call(['sudo', '-n', '--', 'ip', 'tuntap',
                               'add', 'dev', self.tapname,
                               'mode', 'tap',
                               'user', str(os.getuid()),
                               'group', str(os.getgid())])
        subprocess.check_call(['sudo', '-n', '--', 'ip', 'link', 'set', 'dev', self.tapname, 'up'])
        subprocess.check_call(['sudo', '-n', '--', 'brctl', 'addif', self.bridge.name, self.tapname])        

    def run(self):
        opts = self.opts

        # setup run CD:
        if not opts.cdrom:
            self.iso=None
        elif os.path.isdir(opts.cdrom):
            self.iso = os.path.join(self.tmpdir,"run.iso")
            if subprocess.call(["genisoimage", "-quiet", "-R",
                                "-input-charset", "utf-8", "-o",
                                self.iso, opts.cdrom]):
                raise RuntimeError("Could not create cdrom from dir: "+opts.cdrom)
        else:
            self.iso = opts.cdrom

        # generates scratch drives:
        self.drives = []
        if opts.scratch:
            sizes = opts.scratch.split(",")
            i = 1;
            for size in sizes:
                if size.strip():
                    name = os.path.join(self.tmpdir,"disk-"+str(i))
                    i += 1
                    if subprocess.call(["fallocate", "-l", size, name]):
                        logging.warning("Error creating a "+size+" scratch drive with fallocate. Trying dd")
                        if subprocess.call(["dd", "if=/dev/zero", "of="+name, "count=1", "bs="+size]):
                            raise RuntimeError("Error creating a "+size+" scratch drive with dd")
                    self.drives.append(name)

        # build qemu command and start
        cmd = ["qemu-system-x86_64"]
        cmd.extend(["-machine", "accel=kvm"])
        cmd.extend(["-pidfile", os.path.join(self.tmpdir,"pid",)])
        cmd.extend(["-m", opts.mem])
        cmd.extend(["-smp", "%d,sockets=%d" % (int(opts.cpus), int(opts.cpus))])
        if opts.kernel:
            cmd.extend(["-kernel", opts.kernel])
            kernelParams = "console=ttyS0,115200 kgdboc=ttyS2,115200"
            kernelParams += " ip="+self.ipaddr
            if opts.append:
                kernelParams += " "+opts.append
            cmd.extend(["-append", kernelParams])
        if opts.initrd:
            cmd.extend(["-initrd", opts.initrd])
        cmd.extend(["-nographic"])
        cmd.extend(["-serial", self.console])
        cmd.extend(["-serial", "mon:unix:" + os.path.join(self.tmpdir,"con")+",server,nowait"])
        cmd.extend(["-serial", "unix:" + os.path.join(self.tmpdir,"gdb")+",server,nowait"])
        cmd.extend(["-monitor", "unix:" + os.path.join(self.tmpdir,"mon")+",server,nowait"])
        if opts.persistant:
            cmd.extend(["-drive", "format=raw,file="+opts.image])
        else:
            cmd.extend(["-drive", "format=raw,snapshot=on,file="+opts.image])
        if opts.filesystems:
            for fspath, fslabel in opts.filesystems:
                cmd.extend(["-virtfs", "local,path="+fspath+",mount_tag="+fslabel+",security_model=none"])
        for drive in self.drives:  # add scratch drives
            cmd.extend(["-drive", "if=virtio,format=raw,cache=writeback,file="+drive])
        if self.iso:              # add cdrom
            cmd.extend(["-cdrom", self.iso])
        cmd.extend(["-netdev","tap,id=eth0,ifname=%s,script=no,downscript=no" % self.tapname])
        cmd.extend(["-device","virtio-net-pci,netdev=eth0,mac="+self.macaddr])

        self.proc = subprocess.Popen(cmd, shell=False, close_fds=True)

        return self.proc

    def cleanup(self):
        """Cleanup tasks for this vm after it has terminated
        """
        # Take down the tap device.  It is not necessary to down the
        # tap device or remove it from the bridge, that happens
        # automatically.
        subprocess.check_call(['sudo','-n', '--', 'ip', 'tuntap', 'del', 'dev', self.tapname, 'mode', 'tap'])


class Cluster(object):
    """Defines a cluster of VMs attachd to a single virtual bridge.
    """

    def __init__(self, num_of_vms, opts):
        """Initialize the cluster object with bridge information.
        """

        bridge = bridge_get()

        self.idnum    = bridge.br_num               # int version of id
        self.br_key   = bridge.br_key               # key of bridge
        self.idstr    = str(self.idnum)             # str version of id
        self.idhex    = hex(self.idnum+256)[-2:]    # hex version of id
        self.name     = "vmbr%s" % self.idstr       # bridge name
        self.vms      = []                          # list of vms in cluster

        self.owner    = getpass.getuser()           # who "owns" this cluster

        # IPv4 parameters
        self.ipaddr   = self.ipgen(1)               # bridge ip addresss
        self.ipnet    = self.ipgen(0)               # vm network base addresss
        self.cidr     = 24                          # CIDR mask (netmask)

        # IPv6 parameters
        self.ipv6addr = self.ipv6gen(1)             # bridge IPv6 address
        self.ipv6net  = self.ipv6gen(0)             # IPv6 network
        self.v6cidr   = 64                          # IPv6 CIDR (netmask)

        self.status   = "inactive"                  # cluster status
        self.tmpdir   = opts.tmpdir

        # Set the dnsmasq file attributes and wipe the files
        for dnattr in ["conf", "pid", "leases", "hostsfile", "addnhosts", "output"]:
            dnfile=os.path.join(self.tmpdir, "%s.dnsmasq.%s" % (self.name, dnattr))
            setattr(self, "dnsmasq_%s" % dnattr, dnfile)
            open(dnfile, 'w').close() # Truncate/create

        slotfile = os.path.join(self.tmpdir,'id')
        if os.path.exists(slotfile):
            os.remove(slotfile)

        if opts.indexfile:
            if os.path.exists(opts.indexfile):
                os.remove(opts.indexfile)

        # for each VM, grab a VM object and add it to cluster's VM list
        for vm in range(num_of_vms):

            vm_name = "vm%d-%s" % (vm+2, self.name)

            vm_tmpdir = os.path.join(self.tmpdir,
                vm_name+"-"+self.owner)

            slot = vm_slot_get(vm_tmpdir, self.ipgen(vm+2), opts.conx3)

            appendfile(slotfile, slot.vm_id)
            if opts.indexfile:
                appendfile(opts.indexfile, slot.vm_id)

            if vm == 0:
                vm_console = opts.console
            else:
                vm_console = 'file:%s' % os.path.join(vm_tmpdir, "console")

            self.vms.append(ClusteredVM(vm+2, self, opts, slot, vm_tmpdir, vm_console))


    # Network address generators indexed off node number for the MAC address,
    # IPv4 and IPv6 addresses.
    def macgen(self, node):
        return "de:ad:be:ef:%s:%s" % (self.idhex, hex(node+256)[-2:])

    def ipgen(self, node):
        return "172.30.%d.%d" % (self.idnum, node)

    def ipv6gen(self, node):
        return "fd84:c772:8103:fa%s::%s" % (self.idhex, hex(node+256)[-2:])


    def enable_dnsmasq(self):
        """Configure and start dnsmasq
        
        IPv4 will have explicit host entries (hostsfile).

        IPv6 will use router advertisement to pick a random address
        due to the difficulty of determining the DUID-LT in advance.
        """
        with open(self.dnsmasq_conf, "w") as f:
            f.write("strict-order\n")
            f.write("domain-needed\n")
            f.write("domain=%s\n" % self.name)
            f.write("expand-hosts\n")
            f.write("local=/%s/\n" % self.name)
            f.write("pid-file=%s\n" % self.dnsmasq_pid)
            f.write("except-interface=lo\n")
            f.write("bind-dynamic\n")
            f.write("interface=%s\n" % self.name)
            f.write("dhcp-range=%s,%s\n" % (self.ipgen(128), self.ipgen(254)))
            f.write("dhcp-no-override\n")
            f.write("dhcp-range=%s,constructor:%s,slaac,ra-names,%d\n" % (self.ipv6gen(1), self.name, self.v6cidr))
            f.write("dhcp-leasefile=%s\n" % self.dnsmasq_leases)
            f.write("dhcp-lease-max=383\n")
            f.write("dhcp-hostsfile=%s\n" % self.dnsmasq_hostsfile)
            f.write("addn-hosts=%s\n" % self.dnsmasq_addnhosts)

        with open(self.dnsmasq_hostsfile, "w") as f:
            for idx in range(2, 127):
                f.write("%s,%s,node%d\n" % (self.macgen(idx), self.ipgen(idx), idx-1))

        cmd = ['sudo', '-n', '--', 'dnsmasq',
               "--log-facility=-", '--log-queries',
               "--conf-file=%s" % self.dnsmasq_conf, 
               "--user=%s" % self.owner]
        subprocess.check_call(cmd, shell=False, close_fds=True,
                              stdin=FNULL,
                              stdout=open(self.dnsmasq_output, 'w'),
                              stderr=subprocess.STDOUT)

    def disable_dnsmasq(self):
        try:
            with open(self.dnsmasq_pid, 'r') as f:
                pid=int(f.read().strip())
                os.kill(pid, signal.SIGTERM)
        except:
            logging.warning("Failed to terminate dnsmasq")

    def enable_bridge(self):
        """Enable the bridge using bridge control commands.
        """
        subprocess.check_call(['sudo', '-n', '--', 'brctl', 'addbr', self.name])
        subprocess.check_call(['sudo', '-n', '--', 'brctl', 'stp', self.name, 'on'])
        subprocess.check_call(['sudo', '-n', '--', 'brctl', 'setfd', self.name, '2'])
        subprocess.check_call(['sudo', '-n', '--', 'brctl', 'sethello', self.name, '2'])
        subprocess.check_call(['sudo', '-n', '--', 'ip', 'tuntap','add', 'dev', self.name + "-host", 'mode', 'tap'])
        subprocess.check_call(['sudo', '-n', '--', 'brctl', 'addif', self.name, self.name + "-host"])
        subprocess.check_call(['sudo', '-n', '--', 'sysctl', '-q', '-w', "net.ipv6.conf.%s.accept_ra=0" % self.name, "net.ipv6.conf.%s.autoconf=0" % self.name])
        subprocess.check_call(['sudo', '-n', '--', 'ip', 'link', 'set', 'dev', self.name, 'up'])
        subprocess.check_call(['sudo', '-n', '--', 'ip', 'addr', 'add', "%s/%d" %(self.ipaddr, self.cidr), "dev", self.name])
        subprocess.check_call(['sudo', '-n', '--', 'ip', 'addr', 'add', "%s/%d" %(self.ipv6addr, self.v6cidr), "dev", self.name])

        # NAT IPv4 packets off the bridge if supported.  The iptables
        # configuration depends on iptables on the server not being
        # used for anything else.
        subprocess.call(['sudo', '-n', '--', 'sysctl', '-q', '-w', 'net.ipv4.ip_forward=1'])
        subprocess.call(['sudo', '-n', '--', 'iptables', '-t', 'nat', '-I', 'POSTROUTING', '-s', "%s/%d" % (self.ipnet, self.cidr), '!', '-o', self.name, '-j', 'MASQUERADE'])
        subprocess.call(['sudo', '-n', '--', 'iptables', '-t', 'filter', '-I', 'INPUT', '-i', self.name, '-j', 'ACCEPT'])
        subprocess.call(['sudo', '-n', '--', 'iptables', '-t', 'filter', '-I', 'OUTPUT', '-o', self.name, '-j', 'ACCEPT'])
        subprocess.call(['sudo', '-n', '--', 'iptables', '-t', 'filter', '-I', 'FORWARD', '-i', self.name, '-j', 'ACCEPT'])
        subprocess.call(['sudo', '-n', '--', 'iptables', '-t', 'filter', '-I', 'FORWARD', '-o', self.name, '-j', 'ACCEPT'])

        self.status = "enabled"

    def disable_bridge(self):
        """Disable the bridge using bridge control commands.
        """
        # Note, we will leave ip forwarding enabled since there
        # may be other bridges using it.
        subprocess.call(['sudo', '-n', '--', 'iptables', '-t', 'nat', '-D', 'POSTROUTING', '-s', "%s/%d" % (self.ipnet, self.cidr), '!', '-o', self.name, '-j', 'MASQUERADE'])
        subprocess.call(['sudo', '-n', '--', 'iptables', '-t', 'filter', '-D', 'INPUT', '-i', self.name, '-j', 'ACCEPT'])
        subprocess.call(['sudo', '-n', '--', 'iptables', '-t', 'filter', '-D', 'OUTPUT', '-o', self.name, '-j', 'ACCEPT'])
        subprocess.call(['sudo', '-n', '--', 'iptables', '-t', 'filter', '-D', 'FORWARD', '-i', self.name, '-j', 'ACCEPT'])
        subprocess.call(['sudo', '-n', '--', 'iptables', '-t', 'filter', '-D', 'FORWARD', '-o', self.name, '-j', 'ACCEPT'])

        subprocess.call(['sudo', '-n', '--', 'ip', 'link', 'set', 'dev', self.name, 'down'])

        subprocess.call(['sudo', '-n', '--', 'ip', 'tuntap','del', 'dev', self.name + "-host", 'mode', 'tap'])

        subprocess.check_call(['sudo', '-n', '--', 'brctl', 'delbr', self.name])

        bridge_free(self.br_key)

        self.owner = None
        self.status = "disabled"


    # Tear down VMs and networking on a signal or abort
    def terminate_vms(self):
        for vm in self.vms:
            try:
                vm.proc.terminate()
            except:
                pass

    def run(self):
        """Setup and run the cluster.
        """
        for sig in (signal.SIGHUP, signal.SIGINT, signal.SIGQUIT, signal.SIGILL,
                    signal.SIGABRT, signal.SIGFPE, signal.SIGPIPE, signal.SIGTERM,
                    signal.SIGUSR1, signal.SIGUSR2):
            signal.signal(sig, lambda sig, frame: self.terminate_vms())

        # enable the bridge
        self.enable_bridge()

        # Setup dnsmasq on the bridge
        self.enable_dnsmasq()

        # Launch the VMs
        for vm in self.vms:
            vm.setup()
            vm.run()

        # Collect VMs as they finish
        while True:
            for vm in self.vms:
                vm.proc.poll()

            for vm in self.vms:
                if vm.proc.returncode == None:
                    break # Re-poll
            else:
                break # Abort the poll loop
            time.sleep(0.5)

        # Cleanup after the VMs
        for vm in self.vms:
            attempts=0
            while True:
                try:
                    vm.cleanup()
                    break
                except Exception, e:
                    attempts+=1
                    if attempts > 10:
                        logging.warning("Failed to clean up VM %d" % vm.idnum)
                        break
                    else:
                        time.sleep(0.5)

        for vm in self.vms:
            try:
                vm_slot_put(vm.vmsid)
            except:
                logging.warning("Failed to return the slot for %d" % vm.vmsid)

        # terminate dnsmasq
        self.disable_dnsmasq()

        # disable the bridge
        self.disable_bridge()

def cmd_start():
    """Start new virtual machines
    """
    opt = OptionParser("Usage: %prog start [options] [number]",
        description="Start a virtual machine or cluster")

    opt.add_option("-d", "--debug", dest="debug",
                   default=False, action="store_true",
        help="enable debugging")

    opt.add_option("-i", "--image", dest="image",
        help="boot image of the virtual machine(s)")

    opt.add_option("-k", "--kernel", dest="kernel",
        help="kernel used to boot the virtual machine(s)")

    opt.add_option("-r", "--initrd", dest="initrd",
        help="initial ramdisk for boot")

    opt.add_option("-a", "--append", dest="append",
        default="root=/dev/sda rw",
        help="append kernel command line boot arguments")

    opt.add_option("-c", "--cdrom-source", dest="cdrom",
        help="cdrom image or directory to convert into a cdrom image")

    opt.add_option("-s", "--scratch-dev ", dest="scratch",
        default="",
        help="list of scratch device sizes. ex: 256M,2G")

    opt.add_option("-t", "--tmpfs-dir", dest="tmpfs",
        default=DEFAULT_TMP,
        help="location of the tmpfs directory for scratch devices")

    opt.add_option("-m", "--memory", dest="mem",
        default=DEFAULT_MEMORY,
        help="amount of memory to be allocated per VM")

    opt.add_option("-C", "--core", dest="core",
        default=None,
        help="file used for log and core")

    opt.add_option("--cpus", dest="cpus",
        default="1",
        help="number of CPUs allocated per VM")

    opt.add_option("-p", "--persistant", dest="persistant",
        action="store_true",
        help="use writeback")

    opt.add_option("--fs", dest="filesystems",
        action="append", nargs=2,
        help="mount a directory (first argument) as " +
        "a filesystem label (second argument) in the VM")

    opt.add_option("--id", dest="indexfile",
        help="file to write vm number to")

    opt.add_option("--console", dest="console",
        default="stdio",
        help="where to attach the vm console (ex: stdio, file:foo)")

    opt.add_option("--conx3", dest="conx3",
        default=False, action="store_true",
        help="assign a virtual pci connect x3 nic for rdma")

    opt.add_option("--cluster", dest="cluster",
        help="Start a cluster with the specified number of nodes")

    (options, args) = opt.parse_args()

    if options.debug:
        logging.getLogger().setLevel("DEBUG")

    tmpdate = datetime.datetime.strftime(
        datetime.datetime.today(),"%Y%m%d-%H%M%S")
    
    options.tmpdir = os.path.join(
        options.tmpfs,"vm-%s-%s" % (tmpdate, randstr()))

    # generate tmp dir
    os.makedirs(options.tmpdir, 0700)
        
    if options.cluster:
        
        cluster = Cluster(int(options.cluster),options)

        cluster.run()

    else:

        # path for single vm

        if not options.image:
            raise RuntimeError("Requires an image to boot")

        if not os.path.isfile(options.image):
            raise RuntimeError("Cannot find base image file: "+options.image)

        #if not options.kernel:

        if options.kernel and not os.path.isfile(options.kernel):
            raise RuntimeError("Cannot find kernel file: "+options.kernel)

        if options.initrd and not os.path.isfile(options.initrd):
            raise RuntimeError("Cannot find initrd file: "+options.initrd)

        try:
            caught_signal = False

            def sighandler(signum, stack):
                if not caught_signal:
                    caught_signal = True
                    raise Exception("signal caught")

            for i in [x for x in dir(signal) if x.startswith("SIG")]:
                if i in ['SIGHUP', 'SIGINT', 'SIGQUIT', 'SIGILL', 'SIGABRT',
                    'SIGFPE', 'SIGSEGV', 'SIGPIPE', 'SIGALRM', 'SIGTERM',
                    'SIGUSR1', 'SIGUSR2']:
                    signum = getattr(signal, i)
                    signal.signal(signum, sighandler)

            vm = vm_slot_get(options.tmpdir, None, options.conx3)

            idfile = os.path.join(options.tmpdir,'id')

            writefile(idfile, vm.vm_id)
            if options.indexfile:
                writefile(options.indexfile, vm.vm_id)

            # setup run CD:
            if not options.cdrom:
                iso=None
            elif os.path.isdir(options.cdrom):
                iso = options.tmpdir + "/run.iso"
                if subprocess.call(["genisoimage", "-quiet", "-R",
                    "-input-charset",
                    "utf-8", "-o", iso, options.cdrom]):
                    raise RuntimeError("Could not create cdrom from dir: "+options.cdrom)
            else:
                iso=options.cdrom

             # generates scratch drives:
            drives = []
            if options.scratch:
                sizes = options.scratch.split(",")

                i = 1;
                for size in sizes:
                    if size.strip():
                        name = options.tmpdir + "/disk-" + str(i)
                        i += 1

                        if subprocess.call(["fallocate", "-l", size, name]):
                            logging.warning("fallocate error, trying dd")
                            if subprocess.call(["dd", "if=/dev/zero", "of="+name,
                                "count=1", "bs="+size]):
                               raise RuntimeError("error creating scratch drive '"+name+"'")
                        drives.append(name)

            # generate log and core dump device
            if options.core:
                (name,size) = options.core.split(",")
                if size==None:
                    size="10G"
                if subprocess.call(["fallocate", "-l", size, name]):
                    logging.warning("fallocate error, trying dd")
                    if subprocess.call(["dd", "if=/dev/zero", "of="+name,
                                        "count=1", "bs="+size]):
                        raise RuntimeError("error creating core/log drive '"+name+"'")
                if subprocess.call(["mkfs.ext4", "-U","11111111-2222-3333-4444-555555555555","-F",name]):
                    raise RuntimeError("mkfs.ext4 failed on '"+name+"'")


            # build qemu command and start
            cmd = ["qemu-system-x86_64"]
            cmd.extend(["-machine", "accel=kvm"])
            cmd.extend(["-pidfile", options.tmpdir + "/pid"])
            cmd.extend(["-m", options.mem])
            cmd.extend(["-smp", "%d,sockets=%d" % (int(options.cpus), int(options.cpus))])

            if options.kernel:
                cmd.extend(["-kernel", options.kernel])
                kernelParams = "console=ttyS0,115200 kgdboc=ttyS2,115200"
                if options.append:
                    kernelParams += " "+options.append
                cmd.extend(["-append", kernelParams])

            if options.initrd:
                cmd.extend(["-initrd", options.initrd])

            cmd.extend(["-nographic"])
            cmd.extend(["-serial",  options.console])
            cmd.extend(["-serial",  "mon:unix:" + options.tmpdir + "/con,server,nowait"])
            cmd.extend(["-serial",  "unix:" + options.tmpdir + "/kgdb,server,nowait"])
            cmd.extend(["-monitor", "unix:" + options.tmpdir + "/mon,server,nowait"])
            cmd.extend(["-gdb", "unix:" + options.tmpdir + "/gdb,server,nowait"])
    
            # Drives:
            if options.persistant:
                cmd.extend(["-drive", "format=raw,file="+options.image])
            else:
                cmd.extend(["-drive", "format=raw,snapshot=on,file="+options.image])
            if options.filesystems:
                for fspath, fslabel in options.filesystems:
                    cmd.extend(["-virtfs", "local,path="+fspath+",mount_tag="+fslabel+",security_model=none"])
            if options.core:
               cmd.extend(["-drive", "format=raw,file="+options.core.split(",")[0]])

            for drive in drives:  # add scratch drives
                cmd.extend(["-drive", "if=virtio,format=raw,cache=writeback,file="+drive])

            if iso:              # add cdrom
                cmd.extend(["-cdrom",iso])
 
            cmd.extend(["-net", "nic,model=virtio"])
            cmd.extend(["-net", "user,host=10.0.2.2,restrict=off,hostfwd=tcp:127.0.0.1:" + str(vm.vm_id + 9000) + "-:22"])
    
            if options.conx3:
                print "Assigning vf: ", vm.conx3_id
                cmd.extend(["-device", "pci-assign,host="+str(vm.conx3_id)])
        
            logging.warning("Executing: "+str(cmd))
            
            p = subprocess.Popen(cmd, shell=False)

            vm.pid = p.pid
            vm.status="running"
            print GREEN+"Vm ID: "+str(vm.vm_id)+NC
    
            p.wait()
        except:
            pass
    
    vm_cleanup(options.tmpdir)
    subprocess.call(["stty", "sane"],
                    stdout=FNULL,
                    stderr=subprocess.STDOUT)

def cmd_stop():
    """Stop virtual machines by id or ipaddr
    """

    opt = OptionParser("Usage: %prog stop [options] [id]",
        description="Stop a vm by its id or its ip address")

    opt.add_option("-d", "--debug", dest="debug",
                   default=False, action="store_true",
        help="enable debugging")

    opt.add_option("-i", "--ip", dest="ipaddr",
      help="The ip address of the vm")

    (opts, args) = opt.parse_args()

    if opts.debug:
        logging.getLogger().setLevel("DEBUG")


    if opts.ipaddr:
        os.system(
          "ssh -o StrictHostKeyChecking=no -i id_dsa %s 'shutdown -h now'"
          % opts.ipaddr)
    else:

        if len(args) == 0:
            raise RuntimeError("Please provide a vm id or ip address to stop")

        ids = args[0].split("/") 
        
        for id in ids:
            vm = vm_lookup(int(id))
            pid = readfile(vm.tmpdir + '/pid')
            os.kill(int(pid), signal.SIGKILL)


def cmd_ssh():
    """ssh into a virtual machine"""

    if len(sys.argv) <= 1:
        raise RuntimeError("Please provide a vm id to SSH to")

    id = int(sys.argv[1].split('/')[0])
    vm = vm_lookup(id)

    keyfile = os.path.dirname(os.path.realpath(__file__)) + "/id_dsa"
    os.system("chmod 600 " + keyfile)

    if vm.ip and (vm.ip[:7]!='172.20.'):
        cmd = ["ssh", "-o", "StrictHostKeyChecking=no", "-o",
            "UserKnownHostsFile=/dev/null", "-i", keyfile, "root@"+vm.ip]
    else:
        cmd = ["ssh", "-o", "NoHostAuthenticationForLocalhost=yes",
            "-i", keyfile, "-p", str(9000 + id), "root@127.0.0.1"]

    cmd.extend(sys.argv[2:])
    os.execvp("ssh", cmd)


def vm_gdb(gdbsocket):
    if len(sys.argv) <= 2:
        raise RuntimeError("Please provide a vm ID and a vmlinux file")

    vm = vm_lookup(int(sys.argv[1]))
    os.execlp("gdb", "gdb",
          "-ex", "set remote interrupt-on-connect",
          "-ex", "target remote | socat UNIX-CONNECT:" +
          os.path.join(vm.tmpdir, gdbsocket) + ' -', sys.argv[2])


def cmd_gdb():
    vm_gdb('gdb')


def cmd_kgdb():
    vm_gdb('kgdb')


def cmd_mon():
    if len(sys.argv)<=1:
        raise RuntimeError("Please provide a vm id")

    vm = vm_lookup(int(sys.argv[1]))

    os.execlp("minicom", "minicom",
          "-D", "unix#" + vm.tmpdir + "mon")

def cmd_check():
    """Check if a specific resource is available
    """

    opt=OptionParser("usage: %prog vm list [session_id]",
             description="""List out running VMs""")

    opt.add_option("-d", "--debug", dest="debug",
                   default=False, action="store_true",
        help="enable debugging")

    (options, args) = opt.parse_args()

    if options.debug:
        logging.getLogger().setLevel("DEBUG")

    if len(args) == 0 or args[0] == "vms":
        d = openLockedDb(IP_FILE_LOCK, IP_FILE_DICT)
        running_vms = d["running_vms"]
        closeLockedDb(d)
        if (MAX_VMS - len(running_vms)) == 0:
            raise RuntimeError("No VMs available")
        
    elif args[0] == "bridges":
        d = openLockedDb(BR_FILE_LOCK, BR_FILE_DICT)
        bridges = d["bridges"]
        closeLockedDb(d)
        avail = False
        for bridge in bridges.itervalues():
            avail |= bridge.available
        if not avail:
            raise RuntimeError("No bridges available")

    elif args[0] == "conx3":
        d = openLockedDb(IP_FILE_LOCK, IP_FILE_DICT)
        running_vms=d["running_vms"]
        closeLockedDb(d)
        cards = list_conx3()
        for vm in running_vms:
            if vm.conx3_id in cards:
                cards.remove(vm.conx3_id)
        if len(cards) == 0:
            raise RuntimeError("ConnectX3 is not available")


def cmd_list():
    """List out running VMs"""
    opt=OptionParser("usage: %prog vm list [session_id]",
             description="""List out running VMs""")

    opt.add_option("-d", "--debug", dest="debug",
                   default=False, action="store_true",
        help="enable debugging")


    (options, args) = opt.parse_args()

    if options.debug:
        logging.getLogger().setLevel("DEBUG")

    if len(args) == 0 or args[0] == "vms":
        
        # get running vms:
        d = openLockedDb(IP_FILE_LOCK, IP_FILE_DICT)
        running_vms = d["running_vms"]
        closeLockedDb(d)
    
        running_vms = sorted(running_vms, key=operator.attrgetter("owner", "vm_id"))
    
        print "Domain\tIP\t\tConX3 id\tOwner\tDead"
        print "------\t------------\t--------\t-----\t----"
    
        for vm in running_vms:
            mia=" " if vm.exists() == True else "X"
            print (str(vm.name) + "\t" + str(vm.ip) + "\t" +
                str(vm.conx3_id) + "\t\t" +
                str(vm.owner) + "\t" + mia)

    elif args[0] == "bridges":
        d = openLockedDb(BR_FILE_LOCK, BR_FILE_DICT)
        bridges = d["bridges"]
        closeLockedDb(d)

        bridges = bridges.values()
       
        bridges = sorted(bridges, key=operator.attrgetter("br_name"))
        print "Bridge\tAvailable?"
        print "------\t----------"
        for br in bridges:
            print br.br_name+"\t"+str(br.available)

    elif args[0] == "conx3":
        cards = list_conx3()
        print "Cards"
        print "-------"
        for card in cards:
            print card

cmd_ls = cmd_list

def cmd_purge():
    """Purge entries from a partially broken database"""

    opt=OptionParser("usage: %prog purge [object, object, ...]",
             description="""Purge entries from a partially broken database""")

    opt.add_option("-d", "--debug", dest="debug",
                   default=False, action="store_true",
        help="enable debugging")

    (options, args) = opt.parse_args()

    if options.debug:
        logging.getLogger().setLevel("DEBUG")

    vms_by_id=[]
    vms_by_name=[]
    brs_by_name=[]
    for entry in args:
        if (entry[:2] == "vm") and entry[2:].isdigit():
            vms_by_name.append(entry)
        elif (entry[:2] == "br") and entry[2:].isdigit():
            brs_by_name.append(entry)
        elif entry.isdigit():
            vms_by_id.append(int(entry))
        else:
            raise ValueError("Cannot infer type of entry: %s" % entry)

    vmdb = openLockedDb(IP_FILE_LOCK, IP_FILE_DICT)
    running_vms = vmdb["running_vms"]
    new_vms = []
    for vm in running_vms:
        if (vm.vm_id not in vms_by_id) and (vm.name not in vms_by_name):
            new_vms.append(vm)

    vmdb["running_vms"] = new_vms
    closeLockedDb(vmdb)

    brdb = openLockedDb(BR_FILE_LOCK, BR_FILE_DICT)
    bridges = brdb["bridges"]
    for bridge in bridges.itervalues():
        if bridge.br_name in brs_by_name:
            bridge.available = True

    brdb["bridges"]=bridges
    closeLockedDb(brdb)
    


def gendbs(dbname, description, lockfile, dbfile, callback):
    """Generic function to generate database files (union of duplicated code).

    cmdname       Name of the database being created (ips, bridges)
    description   Help text
    lockfile      Name of the lockfile to be created
    dbfile        Name of the database file to be created
    callback      callable object to populate the database
                  (passed an open shelve object as its argument)
    """
    opt=OptionParser("usage: %prog vm gen" + dbname,
                     description=description)

    opt.add_option("-d", "--debug", dest="debug",
                   default=False, action="store_true",
        help="enable debugging")

    opt.add_option("-s", "--safe", dest="safe",
                   default=False, action="store_true",
                   help="Automatic, but only if the lock and dbfile do not exist")
    opt.add_option("-f", "--force", dest="force",
                   default=False, action="store_true",
                   help="Automatic, force overwrite")
    (options, args) = opt.parse_args()

    if options.debug:
        logging.getLogger().setLevel("DEBUG")

    if options.force and options.safe:
        raise RuntimeError("--safe and --force are mutually exclusive")

    if os.geteuid() != 0:
        raise RuntimeError("Root permissions are required")

    if not (options.force or options.safe):
        check = raw_input("This will overwrite any current %s database files. Are you sure? (y): " % dbname)
        if check != "y":
            sys.exit(0)

    # make directory
    try:
        os.mkdir("/etc/vms")
    except OSError as e:
        if e.errno != errno.EEXIST:
            raise

    lockFD = os.open(lockfile, os.O_RDWR | os.O_CREAT)
    try:
        if options.safe:
            fcntl.flock(lockFD, fcntl.LOCK_EX)
            if os.path.exists(dbfile):
                print "Already setup"
                return

        os.fchmod(lockFD, 0666)
        os.lseek(lockFD, 0, os.SEEK_SET)
        os.ftruncate(lockFD, 0)
        os.write(lockFD, "used for locking access to %s database file" % dbname)

        db = shelve.open(dbfile)
        db["sess_id"]=1000

        callback(db)

        db.close()
        os.chmod(dbfile, 0666)

        print "Setup completed"

    finally:
        # This will implicitly release the lock
        os.close(lockFD)


def cmd_genips():
    """
    Generates a new set of new IP Macaddress combinations for
    and puts them in the proper locations:
    Vm.ips-dict - shelve dictionary used by python

    For use when setting up networking on a new machine, or if
    any of the config files get screwed up.
    """

    def ips_generator(d):
        d["running_vms"] = []

    gendbs("ips", "Generate a new IP/MAC file", IP_FILE_LOCK, IP_FILE_DICT, ips_generator)


def cmd_genbridges():
    """
    Generates a new set of bridges

    For use when setting up networking on a new machine, or if
    any of the config files get screwed up.
    """

    def bridges_generator(db):
        bridges = {}

        for br_num in range (1,100):
            #generate bridge file
            br_key = str(br_num)
            br_name = "br"+br_key
            bridges[br_key] = Bridge(br_key,br_num,br_name)

        db["bridges"] = bridges

    gendbs("bridges", "Generate a new bridge file", BR_FILE_LOCK, BR_FILE_DICT, bridges_generator)


def list_conx3():
    """Return the device IDs of all Mellanox ConnectX-3 Virtual Functions
       on the system which are detached from the Mellanox driver and
       are usable for VMs.
    
    Note:

    This requires system preparation to create the virtual, detached cards.

    On the debian machines, /etc/rc.local should use the following commands to reserve
    virtual functions for VMs:
    rmmod mlx4_ib
    rmmod mlx4_core
    echo '15b3 1004' > /sys/bus/pci/drivers/pci-stub/new_id
    modprobe mlx4_core num_vfs=16 probe_vf=16

    As we get new versions of the cards, the above stanza and this
    code needs to be updated to reflect proper PCI device IDs.
    """
    cards=[]

    for ent in os.listdir(CX3_PCI_STUB_DIR):
        devent = os.path.join(CX3_PCI_STUB_DIR, ent)
        try:
            with open(os.path.join(devent, "vendor")) as f:
                dev_vendor = int(f.read().strip(),16)
            with open(os.path.join(devent, "device")) as f:
                dev_device = int(f.read().strip(),16)
            if ((dev_vendor in CX3_VENDOR_IDS) and (dev_device in CX3_DEVICE_IDS)):
                cards.append(':'.join(ent.split(':')[1:]))
        except IOError as e:
            if e.errno not in (errno.ENOENT, errno.ENOTDIR):
                raise

    return cards


def cmd_help():
    """Print help for commands."""
    print """Usage: vm-start [command] [args]

  Commands:
    start       setup and start a vm or a vm cluster
    stop        stop a vm by id or, for a cluster,
                all vms or a single by name
    ssh         ssh to a virtual machine by id
    gdb         connect to gbd
    kgdb        connect to kgdb
    mon         connect to the qemu monitor
    check       check whether there are free resources
    list        list all running vms
    genips      generate a fresh vm database
    genbridges  generate a fresh bridges database
    help        print help for commands
    """

"""Main program."""

# Configure logging
logging.basicConfig(stream=sys.stderr,format='%(levelname)s: %(message)s',level=logging.WARNING)

try:
    # if there is no command or args, print error message
    if len(sys.argv) == 1:
        cmd_help()
        raise RuntimeError("Please provide a command and appropriate arguments.")

    # if first arg is a help option or command, print help and exit
    if sys.argv[1] in ["-h", "--help", "help"]:
        cmd_help()
        sys.exit(0)

    # try to find the command in the global namespace
    try:
        _cmd_name = "cmd_" + sys.argv[1]
        _cmd_func = getattr(sys.modules[__name__], _cmd_name)
    except AttributeError:
        raise RuntimeError("<%s> is not a valid command.\n" % sys.argv[1] +
          "Try 'vm-cluster help' for more info.")

    # remove the command from argv and execute the command function
    sys.argv.pop(1)
    _cmd_func()
except Exception as e:
    logging.error("%s: %s" % (type(e).__name__, e))
    logging.debug(traceback.format_exc())
    sys.exit(1)

sys.exit(0)
