#!/usr/bin/python
# Copyright (c) 2013 Datera, Inc. All rights reserved
# Datera, Inc. Confidential and Propriatory

import sys
import os
import fcntl
import subprocess
import shelve
import shutil
import signal
import operator
import time
import string
import random
import re

from optparse import OptionParser, OptionGroup

# script directory and path
DIR=os.path.dirname(__file__)       # path to script directory

# global info file settings:
IP_FILE = "/etc/vms/ips"
PCI_CONNECTX3_FILE = "/etc/vms/pci_connectx3"
IP_FILE_LOCK = IP_FILE+".lock"      # File we use to lock access to VM info list or dict
IP_FILE_DICT = IP_FILE+".dict"      # Shelf file used to store vm information as python objects

PCI_CONNECTX3_FILE_LOCK = PCI_CONNECTX3_FILE+".lock"
				    # File we use to lock access to VM info list or dict
PCI_CONNECTX3_FILE_DICT = PCI_CONNECTX3_FILE+".dict"
				    # Shelf file used to store vm information as python objects

MAX_VMS = 100                       # Max number of VMs. Currently this is pretty arbitrary.

DEFAULT_MEMORY = "1G"               # how much memory to give the vms
DEFAULT_TMP = "/tmp"                # default directory for tmps
DEFAULT_TIMEOUT = 10*60             # timeout: 10 mins

USER_NETWORKING = True

# colors:
GREEN='\033[32m'
CYAN='\033[36m'
NC='\033[0m'

DEVNULL = open(os.devnull, "wb")

"""
Print Error:
"""
def die(msg, exitStatus=1):
    print >> sys.stderr, "vm-script error: "+msg
    sys.exit(exitStatus)

def warning(msg):
    print >> sys.stderr, "vm script warning: "+msg

def randStr(size=12, chars=string.letters + string.digits):
    return "".join(random.choice(chars) for x in range(size))

def readfile(filename):
    f = open(filename, 'r')
    line = f.readline()
    f.close()
    return line

def writefile(filename, line):
    f = open(filename, 'w')
    print >>f, line
    f.close()

"""
Functions of opening shelf to lock while
reading and writing to shelf file
"""
def openLockedDb(file_lock, file_dict):
    lockFD = os.open(file_lock, os.O_RDONLY)
    fcntl.flock(lockFD, fcntl.LOCK_EX)
    db = shelve.open(file_dict)
    db.lockFD = lockFD
    return db

def closeLockedDb(db):
    db.close()
    fcntl.flock(db.lockFD, fcntl.LOCK_UN)
    os.close(db.lockFD)

class Domain:
    """Represents a single virtual machine"""
    def __init__ (self, vm_id, ip, mac):
	self.vm_id = vm_id         # id number for this vm
	self.ip = ip               # ip address
	self.mac = mac             # mac addresss
	self.owner = None          # who started this machine
	self.name = "vm"+str(vm_id)   # name of the vm, can be custom
	self.tmpdir  = None        # the location of dir to store scratch drives
	self.conx3_id = None 	 # dev id of the virtual pci x3 Connect X3 card
    
    def exists(self):
	"""Does the VM this represents actually exists?"""
	if subprocess.call(['pgrep', '--pidfile', self.tmpdir + '/pid',
			    'qemu-system-x86'],
			   stdout=DEVNULL, stderr=DEVNULL):
	    return False
	return True

def vm_conx3_put(conx3_id):
    db = openLockedDb(PCI_CONNECTX3_FILE_LOCK, PCI_CONNECTX3_FILE_DICT)
    free_conx3 = db["free_conx3"]
    free_conx3.append(conx3_id)
    db["free_conx3"] = free_conx3
    closeLockedDb(db)

def vm_conx3_get():
    db = openLockedDb(PCI_CONNECTX3_FILE_LOCK, PCI_CONNECTX3_FILE_DICT)
    free_conx3 = db["free_conx3"]
    if len(free_conx3) == 0:
	closeLockedDb(db)
	die("Not enough virtual connect x3 to start a vms")
    conx3_id = free_conx3.pop()
    if conx3_id=="08:02.0":
       conx3_id = free_conx3.pop()
       # this device is incorrectly reported one that can be used,
       # however it does not work si we just drop it.
    print "conx3_id=",conx3_id
    db["free_conx3"] = free_conx3
    closeLockedDb(db)
    return conx3_id

def vm_slot_put(id):
    d = openLockedDb(IP_FILE_LOCK, IP_FILE_DICT)
    running_vms = d["running_vms"]
    vm = next((vm for vm in running_vms if vm.vm_id == id), None)
    
    if not vm:
	closeLockedDb(d)
	return

    running_vms.remove(vm)
    d["running_vms"] = running_vms
    
    vm.state	= "stopped"
    vm.owner	= None
    vm.pid	= None
    vm.name	= "vm"+str(vm.vm_id)
    vm.base	= None
    vm.kernel	= None
    vm.tmpdir	= None
    vm.vde	= None
    
    if vm.conx3_id is not None:
	vm_conx3_put(vm.conx3_id)
    
    free_vms = d["free_vms"]
    free_vms.append(vm)
    d["free_vms"] =  sorted(free_vms, key=operator.attrgetter("vm_id"), reverse=True)
    closeLockedDb(d)

def vm_slot_get(tmpdir, vde, conx3):
    try:
	user = os.environ["SUDO_USER"]
    except KeyError:
	user = os.environ["USER"]

    if conx3:
	conx3_id = vm_conx3_get()
    else:
	conx3_id = None
    
    #load database:
    d = openLockedDb(IP_FILE_LOCK, IP_FILE_DICT)
    free_vms = d["free_vms"]
    
    # check to make sure we have enough domains
    if len(free_vms) == 0:
	closeLockedDb(d)
	if conx3_id is not None:
	    vm_conx3_put(vm.conx3_id)
	die("Not enough domains to start a vms")
    
    # get domain, mark for setup
    vm = free_vms.pop()
    vm.state	= "setup"
    vm.owner	= user
    vm.tmpdir	= tmpdir
    vm.conx3_id	= conx3_id
    vm.vde	= vde
    
    # save and free up database while launching vms
    d["free_vms"] = free_vms

    running_vms=d["running_vms"]
    running_vms.append(vm)
    d["running_vms"] = running_vms

    closeLockedDb(d)
    return vm

def vm_lookup(id):
    d = openLockedDb(IP_FILE_LOCK, IP_FILE_DICT)
    running_vms = d["running_vms"]
    vm = next((vm for vm in running_vms if vm.vm_id == id), None)
    
    # make sure we actually found some
    if not vm:
	closeLockedDb(d)
	die("vm " + str(id) + " not running")
    
    closeLockedDb(d)
    return vm

def vm_cleanup(vmdir):
    try:
	pid = readfile(vmdir + '/pid')
	os.kill(int(pid), signal.SIGKILL)
    except:
	pass
    
    try:
	vm_slot_put(int(readfile(vmdir + '/id')))
    except:
	pass
    
    try:
	shutil.rmtree(vmdir)
    except:
	pass

def cmd_start():
    """Start new virtual machines"""

    opt=OptionParser("usage: %prog vm start [number]",
		     description="""Boot start virtual machines""")
    opt.add_option("-i", "--image", dest="image",
		   help="boot image of the virtual machine")
    opt.add_option("-k", "--kernel", dest="kernel",
		   help="kernel qemu should use to boot")
    opt.add_option("-r", "--initrd", dest="initrd",
		   help="initial ramdisk for boot")
    opt.add_option("-a", "--append", dest="append",
		   help="append kernel boot arguments",
		   default="root=/dev/sda rw")
    opt.add_option("-c", "--cdrom-source", dest="cdrom",
		   help="source to made into a cdrom")
    opt.add_option("-s", "--scratch-dev ", dest="scratch",
		   help="list of scratch device sizes. ex: 256M,2G")
    opt.add_option("-t", "--tmpfs-dir", dest="tmpfs", default=DEFAULT_TMP,
		   help="location of the tmpfs directory. Only used for scratch devs")
    opt.add_option("-m", "--memory", dest="mem", default=DEFAULT_MEMORY,
		   help="amount of memory to be allocated per VM")
    opt.add_option("--cpus", dest="cpus", default="1",
		   help="number of CPUs allocated.")
    opt.add_option("-p", "--persistant", dest="persistant", action="store_true",
		   help="turns off snapshot, so writeback happens to disk instead of tmp")
    opt.add_option("--fs", dest="filesystems", action="append", nargs=2,
		   help="mount a directory (first argument) as a filesystem label (second argument) in the VM")
    opt.add_option("--id", dest="indexfile", help="file to write vm number to")
    opt.add_option("--conx3", action="store_true", dest="conx3", default=False,
		   help="assign a virtual pci connect x3 nic for rdma")
    opt.add_option("--vde", dest="vde", action="store_true", 
		   help="use vde networking instead of user mode. This requires a vde"+
		   "switch to be set up, and an dns setup to listen")
    (options, args) = opt.parse_args()
    
    if not options.image:
	die ("Requires an image to boot")
    if not os.path.isfile(options.image):
	die("Cannot find base image file: "+options.image)
    #if not options.kernel:
    #   die("Requires a kernel to boot")
    if options.kernel and not os.path.isfile(options.kernel):
	die("Cannot find kernel file: "+options.kernel)
    if options.initrd and not os.path.isfile(options.initrd):
	die("Cannot find initrd file: "+options.initrd)

    try:
	caught_signal = False

	def sighandler(signum, stack):
	    if not caught_signal:
		caught_signal = True
		raise Exception("signal caught")

	for i in [x for x in dir(signal) if x.startswith("SIG")]:
	    if i in ['SIGHUP', 'SIGINT', 'SIGQUIT', 'SIGILL', 'SIGABRT',
		     'SIGFPE', 'SIGSEGV', 'SIGPIPE', 'SIGALRM', 'SIGTERM',
		     'SIGUSR1', 'SIGUSR2']:
		signum = getattr(signal, i)
		signal.signal(signum, sighandler)

	tmpdir = options.tmpfs + '/vm-' + randStr() + '/'
	os.mkdir(tmpdir, 0700)
	
	vm = vm_slot_get(tmpdir, options.vde, options.conx3)

	writefile(tmpdir + 'id', vm.vm_id)
	if options.indexfile:
	    writefile(options.indexfile, vm.vm_id)
    
	# setup run CD:
	if not options.cdrom:
	    iso=None
	elif os.path.isdir(options.cdrom):
	    iso = tmpdir + "run.iso"
	    if subprocess.call(["genisoimage", "-quiet", "-R", "-input-charset",
			 "utf-8", "-o", iso, options.cdrom]):
		die("Could not create cdrom from dir: "+options.cdrom)
	else:
	    iso=options.cdrom

	# generates scratch drives:
	drives = []
	if options.scratch:
	    sizes = options.scratch.split(",")
	    i = 1;
	    for size in sizes:
		name = tmpdir + "disk-" + str(i)
		i += 1

		if subprocess.call(["fallocate", "-l", size, name]):
		    warning("fallocate error, trying dd")
		    if subprocess.call(["dd", "if=/dev/zero", "of="+name,
					"count=1", "bs="+size]):
			die ("error creating scratch drive")
		drives.append(name)

	# build qemu command and start
	cmd = ["qemu-system-x86_64"]
	cmd.extend(["-machine", "accel=kvm"])
	cmd.extend(["-pidfile", tmpdir + "pid"])
	cmd.extend(["-m", options.mem])
	# LAPIC bug in qemu, shows up occasionally as a kernel panic.
	# Use threads= for smp.
	cmd.extend(["-smp", "1,cores=1,threads=" + options.cpus])
	#cmd.extend(["-vnc", "0.0.0.0:"+str(17100+vm.vm_id)])
	if options.kernel:
	    cmd.extend(["-kernel", options.kernel])
	    kernelParams = "console=ttyS0,115200 kgdboc=ttyS2,115200"
	    if options.vde:
		kernelParams += " ip="+vm.ip
	    if options.append:
		kernelParams += " "+options.append
	    cmd.extend(["-append", kernelParams])
	if options.initrd:
	    cmd.extend(["-initrd", options.initrd])
	cmd.extend(["-nographic"])
	cmd.extend(["-serial",	"stdio"])
	cmd.extend(["-serial",	"mon:unix:" + tmpdir + "con,server,nowait"])
	cmd.extend(["-serial",	"unix:" + tmpdir + "kgdb,server,nowait"])
	cmd.extend(["-monitor",	"unix:" + tmpdir + "mon,server,nowait"])
	cmd.extend(["-gdb",	"unix:" + tmpdir + "gdb,server,nowait"])

	# Drives:
	if options.persistant:
	    cmd.extend(["-drive", "format=raw,file="+options.image])
	else:
	    cmd.extend(["-drive", "format=raw,snapshot=on,file="+options.image])
	if options.filesystems:
	    for fspath, fslabel in options.filesystems:
		cmd.extend(["-virtfs", "local,path="+fspath+",mount_tag="+fslabel+",security_model=none,readonly"])
	for drive in drives:  # add scratch drives
	    cmd.extend(["-drive", "if=virtio,format=raw,cache=writeback,file="+drive])
	if iso:              # add cdrom
	    cmd.extend(["-cdrom", iso])
	if options.vde:   # enable vde networking
	    cmd.extend(["-netdev", "vde,id=vde_net,sock=/tmp/vde.ctl"])
	    cmd.extend(["-device", "virtio-net-pci,netdev=vde_net,mac="+vm.mac])
	    vm.vde = True
	else:             # user networking instead
	    cmd.extend(["-net", "nic,model=virtio"])
	    cmd.extend(["-net", "user,host=10.0.2.2,restrict=off,hostfwd=tcp:127.0.0.1:" + str(vm.vm_id + 9000) + "-:22"])
	    vm.vde = False

	if options.conx3:
	    print "Assigning vf: ", vm.conx3_id
	    cmd.extend(["-device", "pci-assign,host="+str(vm.conx3_id)])

	p = subprocess.Popen(cmd, shell=False)

	vm.pid = p.pid
	vm.status="running"
	print GREEN+"Vm ID: "+str(vm.vm_id)+" IP: "+vm.ip+" MAC: "+vm.mac+NC
    
	p.wait()
    except:
	pass

    vm_cleanup(tmpdir)
    subprocess.call(["stty", "sane"])

def cmd_stop():
    """Stop virtual machines"""
    
    opt=OptionParser("usage: %prog vm stop [id]",
		     description="""Stop virtual machines""")
    (options, args) = opt.parse_args()
     
    if len(args)==0:
	die("Please provide a vm id to stop")

    vm = vm_lookup(int(sys.argv[1]))
    pid = readfile(vm.tmpdir + '/pid')

    os.kill(int(pid), signal.SIGKILL)

def cmd_ssh():
    """ssh into a virtual machine"""
     
    if len(sys.argv) <= 1:
	die("Please provide a vm id to SSH to")

    id = int(sys.argv[1])
    vm = vm_lookup(id)
    
    keyfile = os.path.dirname(os.path.realpath(__file__)) + "/id_dsa"
    os.system("chmod 600 " + keyfile)
     
    if vm.vde:
	cmd = ["ssh", "-o", "StrictHostKeyChecking=no", "-o",
	    "UserKnownHostsFile=/dev/null", "-i", keyfile, "root@"+vm.ip]
    else:
	cmd = ["ssh", "-o", "NoHostAuthenticationForLocalhost=yes",
	    "-i", keyfile, "-p", str(9000 + id), "root@127.0.0.1"]
    
    cmd.extend(sys.argv[2:])
    os.execvp("ssh", cmd)

def vm_gdb(gdbsocket):
    if len(sys.argv) <= 2:
	die("Please provide a vm ID and a vmlinux file")
        
    vm = vm_lookup(int(sys.argv[1]))
    os.execlp("gdb", "gdb",
	      "-ex", "set remote interrupt-on-connect",
	      "-ex", "target remote | socat UNIX-CONNECT:" +
	      vm.tmpdir + gdbsocket + ' -', sys.argv[2])

def cmd_gdb():
    vm_gdb('gdb')

def cmd_kgdb():
    vm_gdb('kgdb')

def cmd_mon():
    if len(sys.argv)<=1:
	die("Please provide a vm id")
    
    vm = vm_lookup(int(sys.argv[1]))
    
    os.execlp("minicom", "minicom",
	      "-D", "unix#" + vm.tmpdir + "mon")

def cmd_list():
    """List out running VMs"""
    opt=OptionParser("usage: %prog vm list [session_id]",
		     description="""List out running VMs""")
    (options, args) = opt.parse_args()
       
    # get running vms:
    d = openLockedDb(IP_FILE_LOCK, IP_FILE_DICT)
    running_vms = d["running_vms"]
    closeLockedDb(d)
    
    running_vms = sorted(running_vms, key=operator.attrgetter("owner", "vm_id"))
    
    print "Domain\tIP\t\tConX3 id\tOwner\tDead"
    print "------\t------------\t--------\t-----\t----"
    
    for vm in running_vms:
	mia=" " if vm.exists() == True else "X"
	print(str(vm.name) + "\t" + str(vm.ip) + "\t" +
	      str(vm.conx3_id) + "\t\t" +
	      str(vm.owner) + "\t" + mia)

def cmd_genips():
    """
    Generates a new set of new IP Macaddress combinations for
    and puts them in the proper locations:
    Vm.ips-dict - shelve dictionary used by python
    
    For use when setting up networking on a new machine, or if
    any of the config files get screwed up.
    """
    
    opt=OptionParser("usage: %prog vm genips",
		     description="""Generate a new IP/MAC file""")
    (options, args) = opt.parse_args()
    
    if os.geteuid() != 0:
	die("You need root permissions to do this, laterz!")
    
    check = raw_input("This will overwrite any current vm list files. Are you sure? (y): ")
    if check != "y":
	sys.exit(0)
    
    # make directory
    if not os.path.isdir("/etc/vms"):
      try:
         os.mkdir("/etc/vms")
      except OSError:
         die("Failed to create /etc/vms")
    
    # generate database files:
    name = "ips"
    
    d = shelve.open(IP_FILE_DICT)
    d["sess_id"] = 1000
    free_vms = []
    lock = open(IP_FILE_LOCK, "w")
    lock.write("used for locking access to vm database file")
    
    for i in range (0, 100):
	#generate IP file
	vm_num = str(i).zfill(2)
	name = "vm"+vm_num
	ip = "172.20.0."+str(i+100)
	mac = "DE:AD:BE:EF:01:"+vm_num
	
	#generate ips dict
	vm = Domain(i, ip, mac)
	free_vms.insert(0, vm)
    
    d["free_vms"] = free_vms
    d["running_vms"] = []
    d.close()
    lock.close()
     
    os.chmod(IP_FILE_DICT, 0666)
    os.chmod(IP_FILE_LOCK, 0666)
    
    print "Setup completed"

def cmd_genconx3():
    """
    Generates a new set of detached virtual Mellanox X3 card
    provided the machine has one. Updates the existing database.
    Your vm can use rdma functionality with this card.
    """

    p = subprocess.Popen(['lspci', '-vvv'], bufsize=-1, stdout=subprocess.PIPE)
    flag = 0
    phys_dev = ""
    for line in p.stdout:
	if flag == 0:
	    if re.search("Mellanox", line):
		entries = re.split('\W+', line)
		searchStr = entries[0] + ':0'
		phys_dev = entries[0] + ':' + entries[1] + '.' + entries[2]
		print phys_dev
		flag = 1
	if flag == 1:
	    if re.search("Number of VFs:", line):
		entries = re.split(',', line)
		entry = re.split(':', entries[0])
		num_vfs='num_vfs=' + str(int(entry[1]))
		entry = re.split(':', entries[1])
		probe_vf='probe_vf=' + str(int(entry[1]))
		entry = re.split(':', entries[2])
		# Number of VFs: 0
		if int(entry[1]) == 0:
		    print "SR-IOV is not yet enabled!"
		    subprocess.call(['rmmod', 'mlx4_ib', 'mlx4_core'])
		    print num_vfs + ' ' + probe_vf
		    subprocess.call(['modprobe', '-v', 'mlx4_core', num_vfs, probe_vf])
		else:
		    print "SR-IOV enabled!"
		break
    p.kill()
    p.wait()

    if flag == 1:
	d = shelve.open(PCI_CONNECTX3_FILE_DICT)
	free_conx3 = []
	lock = open(PCI_CONNECTX3_FILE_LOCK, "w")
	lock.write("used for locking access to pci connect x3 nic database file")
	p = subprocess.Popen(['lspci', '-n'], bufsize=-1, stdout=subprocess.PIPE)
	flag = 0
	for line in p.stdout:
	    m = re.match(searchStr, line)
	    if m:
		entries = re.split(' ', line)
		#entries[0] is the vf id
		#entries[2] is the vendor and the device id
		if not re.match(phys_dev, entries[0]):
		    if flag == 0:
			entry = re.split('[:\n]', entries[2])
			vend_dev_id = entry[0] + ' ' + entry[1]
			f = open('/sys/bus/pci/drivers/pci-stub/new_id', 'w')
			f.write(vend_dev_id)
			f.close()
			flag = 1
		    fn = '/sys/bus/pci/devices/0000:' + entries[0] + '/driver/unbind'
		    devid = '0000:' + entries[0]
		    f = open(fn, 'w')
		    f.write(devid)
		    f.close()
		    f = open('/sys/bus/pci/drivers/pci-stub/bind', 'w')
		    f.write(devid)
		    f.close()
		    # populate the connect x3 pci cards db with these devids
		    free_conx3.append(entries[0])
		    d["free_conx3"] = free_conx3
		    print d["free_conx3"]
	d["free_conx3"] = free_conx3
	d.close()
	lock.close()
	p.kill()
	p.wait()

def cmd_help():
    print """List of valid commands:
	start    starts a vm
	list     list all running vms
	genips   generate a fresh vm database
	genconx3  update db with virtual rdma capable nic
	"""

# main:
if len(sys.argv) == 1:
    cmd_help()
    die("Please give a command")

if sys.argv[1] == "-h":
    cmd_help()
    sys.exit(0)

# try looking up given command in global namespace:
try:
    func = "cmd_"+sys.argv[1]
    func = getattr(sys.modules[__name__], func)
except AttributeError:
    cmd_help()
    die(sys.argv[1]+" is not a valid command")

# check for vm.dict setup:
if func != cmd_genips:
    if not os.path.isfile(IP_FILE_DICT):
	die("Vm list file not found. Please run genips")
    if not os.path.isfile(IP_FILE_LOCK):
	die("Lock file for vm list access not found. Did you run genips?")

sys.argv.pop(1)
func()
