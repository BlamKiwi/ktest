#!/usr/bin/python
# GPLv2

import atexit
import os
import shutil
import signal
import subprocess
import sys
import tempfile
import time
import argparse

DIR = os.path.dirname(__file__)       # path to script directory

DEFAULT_MEMORY = "1G"               # how much memory to give the vms
DEFAULT_TMP = "/tmp"                # default directory for tmps

FNULL = open(os.devnull, 'rw')

def kill_proc(p):
    try:
        p.kill()
    except:
        pass

def qemu_disk(dev, filename, opts="", device="scsi-hd"):
    return ["-drive", "if=none,format=raw,id=" + dev +
            ",file=" + filename + "," + opts,
            "-device", device + ",bus=scsi-hba.0,drive=" + dev]

def qemu_socket(vmdir, vm_nr, name):
    return "unix:" + os.path.join(vmdir, "vm-%u-%s" % (vm_nr, name)) + ",server,nowait"

def vm_run(vmdir, vm_nr):
    cmd = ["stdbuf", "-oL",
           "qemu-system-" + args.architecture,
           "-nodefaults",

           "-m",        args.memory,

           "-nographic",
           "-device",   "virtio-serial",
           "-chardev",  args.console + ",id=console",
           "-device",   "virtconsole,chardev=console",

           "-serial",   qemu_socket(vmdir, vm_nr, "kgdb"),
           "-monitor",  qemu_socket(vmdir, vm_nr, "mon"),
           "-gdb",      qemu_socket(vmdir, vm_nr, "gdb"),
           "-device",   "virtio-rng-pci"
          ]

    if args.architecture == "x86_64":
        cmd.extend(["-cpu",      "host",
                    "-machine", "accel=kvm",
                    "-smp",      "%d,sockets=%d" % (args.cpus, args.cpus)])

    if args.kernel:
        cmd.extend(["-kernel", args.kernel])

    if args.initrd:
        cmd.extend(["-initrd", args.initrd])

    kernelParams = "console=hvc0 root=/dev/sda rw "
    if args.kgdb:
        kernelParams += "kgdboc=ttyS0,115200 "

    if args.append:
        kernelParams += " ".join(args.append)

    cmd.extend(["-append", kernelParams])

    # VirtIO-SCSI for root file system and scratch devices
    cmd.extend(["-device", "virtio-scsi-pci,id=scsi-hba"])

    # Root file system comes first (sda)

    disknr = 0

    for image in args.image:
        cmd.extend(qemu_disk("scsi" + str(disknr), image, "snapshot=on,cache=unsafe"))
        disknr += 1

    for size in args.scratchdev:
        drive = os.path.join(vmdir, "vm-%u-disk-%u" % (vm_nr, disknr))
        subprocess.check_call(["fallocate", "-l", size, drive])
        cmd.extend(qemu_disk("scsi" + str(disknr), drive, "cache=unsafe"))
        disknr += 1

    if args.cdrom:
        cmd.extend(qemu_disk("scsi-cd", args.cdrom, "", "scsi-cd"))

    for fspath, fslabel in args.fs:
        cmd.extend(["-virtfs", "local,path=" + fspath +
                    ",mount_tag=" + fslabel +
                    ",security_model=none"])

    for i in range(args.interfaces):
        mac = "de:ad:be:ef:%0.2x:%0.2x" % (vm_nr, int(i))
        sock = os.path.join(vmdir, "net-" + str(i))

        cmd.extend(["-net", "nic,model=virtio,macaddr=" + mac,
                    "-net", "vde,sock=" + sock])

    atexit.register(kill_proc,
                    subprocess.Popen(cmd,
                                     stderr=subprocess.STDOUT,
                                     stdin=subprocess.PIPE))

def tmpdir_cleanup(vmdir):
    try:
        while True:
            os.wait()
    except:
        pass

    while os.path.isdir(vmdir):
        shutil.rmtree(vmdir, ignore_errors=True)

def cmd_start():
    if args.kernel and not os.path.isfile(args.kernel):
        raise RuntimeError("Cannot find kernel file: " + args.kernel)

    if args.initrd and not os.path.isfile(args.initrd):
        raise RuntimeError("Cannot find initrd file: " + args.initrd)

    if args.scratchdir:
        vmdir = args.scratchdir
    else:
        vmdir = tempfile.mkdtemp(prefix="vm-", dir=args.tmpdir)
        atexit.register(tmpdir_cleanup, vmdir)

    if args.idfile:
        with open(args.idfile, 'w') as f:
            f.write(vmdir + "\n")

    for i in range(args.interfaces):
        net = "10.0.%u.1/24" % (2 + i)
        sock = os.path.join(vmdir, "net-" + str(i))

        atexit.register(kill_proc,
                        subprocess.Popen(["vde_switch",
                                          "-sock", sock],
                                         stdin=subprocess.PIPE,
                                         stdout=FNULL,
                                         stderr=subprocess.STDOUT))

        while not os.path.exists(os.path.join(sock, "ctl")):
            time.sleep(0.1)

        atexit.register(kill_proc,
                        subprocess.Popen(["slirpvde",
                                          "--sock", sock,
                                          "--dhcp=10.0.2.2",
                                          "--host", net],
                                         stdin=subprocess.PIPE,
                                         stdout=FNULL,
                                         stderr=subprocess.STDOUT))

    for vm_nr in range(args.nr_vms):
        vm_run(vmdir, vm_nr)

    while True:
        os.wait()

    try:
        sys.stdout.flush()
    except:
        pass

def vmdir_read():
    with open(args.idfile, 'r') as f:
        path = f.readline()

    return path.strip()

def cmd_ssh():
    vmdir = vmdir_read()

    keyfile = os.path.join(DIR, "ssh_id")
    subprocess.call(["chmod", "600", keyfile])

    tmpdir = tempfile.mkdtemp(prefix="vm-start-", dir=args.tmpdir)
    atexit.register(tmpdir_cleanup, tmpdir)

    lwip_connect = os.path.join(tmpdir, "lwip-connect")

    # this is terrible, but so is automake
    subprocess.check_call(["gcc", "-O2", "-o", lwip_connect,
                           os.path.join(DIR, "lwip-connect.c"),
                           "-llwipv6"])
    ip = "10.0.2." + str(2 + args.vm_nr)
    sock = os.path.join(vmdir, "net-0")

    controlmaster = os.path.join(vmdir, "ssh_master")

    # ServerAliveInterval is a hack - lwip_connect should notice when the socket
    # has gone away an exit, but it appears to be a bug in liblwipv6
    ret = subprocess.call(["ssh", "-t", "-i", keyfile,
                           "-F", "/dev/null",
                           "-o", "CheckHostIP=no",
                           "-o", "StrictHostKeyChecking=no",
                           "-o", "UserKnownHostsFile=/dev/null",
                           "-o", "NoHostAuthenticationForLocalhost=yes",
                           "-o", "ServerAliveInterval=2",
                           "-o", "ControlMaster=auto",
                           "-o", "ControlPath=%s" % controlmaster,
                           "-o", "ControlPersist=yes",
                           "-o", "ProxyCommand=%s %s %s 22" % (lwip_connect, sock, ip),
                           "root@127.0.0.1"] + extra_opts)
    sys.exit(ret)

def vm_gdb(socket):
    os.execvp("gdb",
              ["gdb",
               "-ex", "set remote interrupt-on-connect",
               "-ex", "target remote | socat UNIX-CONNECT:" +
               os.path.join(vmdir_read(), "vm-%u-%s" % (args.vm_nr, socket)) +
               ' -'] + extra_opts)

def cmd_gdb():
    vm_gdb('gdb')

def cmd_kgdb():
    vm_gdb('kgdb')

def cmd_mon():
    os.execlp("minicom", "minicom", "-D", "unix#" +
              os.path.join(vmdir_read(), "vm-%u-mon" % args.vm_nr))

def cmd_sysrq():
    mon_path = os.path.join(vmdir_read(), "vm-%u-mon" % args.vm_nr)

    os.execlp("bash", "bash", "-c",
	      "echo sendkey alt-sysrq-%s | socat - UNIX-CONNECT:%s"
	      % (args.key, mon_path))

# Allow exit handlers to be called
for sig in (signal.SIGHUP,
            signal.SIGINT,
            signal.SIGPIPE,
            signal.SIGALRM,
            signal.SIGTERM,
            signal.SIGUSR1,
            signal.SIGUSR2):
    signal.signal(sig, lambda sig, frame: sys.exit(127))

parser = argparse.ArgumentParser()
parser.add_argument("--idfile", required=True)
parser.add_argument("-t", "--tmpdir",
    default=DEFAULT_TMP,
    help="directory to use for temporary files/scratch devices")
subparsers = parser.add_subparsers()

parser_start = subparsers.add_parser('start',
    help='Start one or more virtual machine(s)')
parser_start.add_argument("--architecture",
    default="x86_64",
    help="qemu architecture")
parser_start.add_argument("--scratchdir",
    help="use a prexisting scratch directory")
parser_start.add_argument("-k", "--kernel",
    help="kernel used to boot the virtual machine(s)")
parser_start.add_argument("-r", "--initrd",
    help="initial ramdisk for boot")
parser_start.add_argument("-a", "--append",
    action='append',
    help="append kernel command line boot arguments")
parser_start.add_argument("--kgdb", action="store_true",
    help="enable kgdb")
parser_start.add_argument("-c", "--cdrom",
    help="cdrom image")
parser_start.add_argument("-i", "--image",
    action="append",
    default=[],
    help="list of disk images for the virtual machine(s)")
parser_start.add_argument("-s", "--scratchdev",
    action="append",
    default=[],
    help="list of scratch device sizes. ex: 256M,2G")
parser_start.add_argument("-m", "--memory",
    default=DEFAULT_MEMORY,
    help="amount of memory to be allocated per VM")
parser_start.add_argument("--cpus",
    default="1", type=int,
    help="number of CPUs allocated per VM")
parser_start.add_argument("--fs",
    action="append", nargs=2,
    help="mount a directory (first argument) as " +
    "a filesystem label (second argument) in the VM")
parser_start.add_argument("--console",
    default="stdio",
    help="where to attach the vm console (ex: stdio, pipe,path=foo)")
parser_start.add_argument("--nr_vms",
    default="1", type=int,
    help="number of virtual machines to start")
parser_start.add_argument("--interfaces",
    default="1", type=int,
    help="Specify the number of interfaces on the cluster nodes")
parser_start.set_defaults(func=cmd_start)

parser_ssh = subparsers.add_parser('ssh',
    help='SSH into a running virtual machine')
parser_ssh.add_argument("--vm_nr", default=0, type=int)
parser_ssh.set_defaults(func=cmd_ssh)

parser_gdb = subparsers.add_parser('gdb',
    help='Run gdb and attach to QEMU')
parser_gdb.add_argument("--vm_nr", default=0, type=int)
parser_gdb.set_defaults(func=cmd_gdb)

parser_kgdb = subparsers.add_parser('kgdb',
    help='Run gdb and attach to kernel (kgdb)')
parser_kgdb.add_argument("--vm_nr", default=0, type=int)
parser_kgdb.set_defaults(func=cmd_kgdb)

parser_mon = subparsers.add_parser('mon',
    help='Attach to QEMU monitor')
parser_mon.add_argument("--vm_nr", default=0, type=int)
parser_mon.set_defaults(func=cmd_mon)

parser_sysrq = subparsers.add_parser('sysrq',
    help='Send magic sysrq key via qemu monitor')
parser_sysrq.add_argument("--vm_nr", default=0, type=int)
parser_sysrq.add_argument("key")
parser_sysrq.set_defaults(func=cmd_sysrq)

(args, extra_opts) = parser.parse_known_args()
args.func()
