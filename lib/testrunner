#!/bin/bash
#
# Test wrapper run inside the VM

set -o nounset
set -o errexit
set -o errtrace

export PS4='+`basename ${BASH_SOURCE[0]}`:${LINENO}:${FUNCNAME[0]:+${FUNCNAME[0]}()}+ '

TEST_RUNNING=1
KERNEL_ARCH=""

. "$KTESTDIR/lib/util.sh"
. "$KTESTDIR/lib/parse-test.sh"

ln -sf "/host/$ktest_kernel/lib/modules" /lib/modules
depmod -a

dmesg --console-on
dmesg --console-level 8

echo 1 > /proc/sys/kernel/sysrq
ulimit -c unlimited

# Log file system visible to host

LOGDIR=/ktest-out
ln -s "/host/$ktest_out" $LOGDIR

# Core dump settings
echo 1 > /proc/sys/fs/suid_dumpable
echo "|/bin/cp --sparse=always /dev/stdin $LOGDIR/core.%e.PID%p.SIG%s.TIME%t" > /proc/sys/kernel/core_pattern
ulimit -c unlimited
rm -f /ktest-out/core.*

# Virtual block device tweaks
for q in /sys/block/sd*/queue; do
    echo noop > $q/scheduler
done

# Check if we are running the crashdump kernel
if [[ -s /proc/vmcore ]]; then
    echo "Collecting crash dump..."
    rm -f "$LOGDIR/vmcore"
    cp --sparse=always /proc/vmcore "$LOGDIR/vmcore" || true
    sync
    poweroff
fi

# If debugging crash dumps, add "console=hvc0" to the append line
# below:
if [[ $ktest_crashdump = 1 ]]; then
    kexec -p /host/$ktest_kernel/vmlinuz --append="root=/dev/sda rw maxcpus=1" || true
fi

NR_REBOOTS=0
EXPECTED_REBOOT=0
[[ -e /NR_REBOOTS ]]		&& NR_REBOOTS=$(</NR_REBOOTS)
[[ -e /EXPECTED_REBOOT ]]	&& EXPECTED_REBOOT=$(</EXPECTED_REBOOT)

if [[ $NR_REBOOTS != $EXPECTED_REBOOT ]]; then
    echo "UNEXPECTED REBOOT: got $NR_REBOOTS expected $EXPECTED_REBOOT"
    echo "TEST FAILED"
    exit 1
fi

echo $((NR_REBOOTS + 1)) | dd of=/NR_REBOOTS oflag=direct 2> /dev/null

if compgen -G "/host/$ktest_tmp/*.deb" > /dev/null; then
    if ! output=$(dpkg -i /host/$ktest_tmp/*.deb); then
	echo $output
	exit 1
    fi
fi

get_stratch_devs()
{
    echo
    sfdisk -X gpt /dev/sdb 
}

copy_to_host()
{
    cat /sys/kernel/debug/tracing/trace >> $LOGDIR/trace.txt

    # Code coverage
    gcov_dir=/sys/kernel/debug/gcov

    if [[ -d $gcov_dir ]]; then
	# find a destination dir that doesn't exist, so we can copy multiple
	# sets of gcov data from different tests/reboots and merge them later

	for i in {0..99}; do
	    dst=$LOGDIR/gcov.$i

	    if [[ ! -d $dst ]]; then
		cp -dR $gcov_dir $dst
		break
	    fi
	done
    fi

    (
        set +e
        fuser -INT -k $LOGDIR $LOGDIR/*
        sync
        #sleep 1
        #fuser -k $LOGDIR $LOGDIR/*
        #umount $LOGDIR
    )
}

check_taint()
{
    read taint < /proc/sys/kernel/tainted

    if [[ $taint != 0 ]]; then
	echo "Failure because kernel tainted - check log for warnings"
	echo "TEST FAILED"
	exit 0
    fi
}

do_reboot()
{
    copy_to_host
    check_taint

    echo $((NR_REBOOTS + 1)) | dd of=/EXPECTED_REBOOT oflag=direct 2> /dev/null
    echo b > /proc/sysrq-trigger
}

PRIORITY=$ktest_priority

parse_test_deps "/host/$ktest_test"

if [[ $(type -t list_tests) == function ]]; then
    tests=$(list_tests)
else
    tests=$(declare -F|sed -ne '/ test_/ s/.*test_// p')
fi

# may be overridden by test:
if [[ $(type -t run_test) != function ]]; then
    run_test()
    {
	test_$1
    }
fi

# may be overridden by test:
if [[ $(type -t run_tests) != function ]]; then
    run_tests()
    {
	local tests=$1
	local tests_passed=()
	local tests_failed=()

	echo
	echo "Running tests $tests"
	echo

	for i in $tests; do
	    echo "========= Running test $i"
	    echo

	    local ret=0
	    (set -e; run_test $i)
	    ret=$?

	    kill $(list_descendants $$) >/dev/null 2>&1 || true

	    echo
	    echo "========= Test $i completed with ret $ret"

	    # XXX: check dmesg for warnings, oopses, slab corruption, etc. before
	    # signaling success

	    if [[ $ret = 0 ]]; then
		tests_passed+=($i)
	    else
		tests_failed+=($i)
	    fi

	    [[ $ret != 0 && $ktest_failfast = 1 ]] && break

	    for dev in /dev/sd*; do
		[[ $dev = /dev/sda ]] && continue
		umount $dev >/dev/null 2>&1 || true
	    done
	done

	echo
	echo "Passed: ${tests_passed[@]}"
	echo "Failed: ${tests_failed[@]}"

	return ${#tests_failed[@]}
    }
fi

if [[ -z $tests ]]; then
    echo "No tests found"
    exit 1
fi

testargs=$(</host/$ktest_tmp/testargs)
[[ -n $testargs ]] && tests="$testargs"

tests=$(echo $tests)

if [[ -n ${ktest_timeout+x} ]]; then
    (
	sleep $ktest_timeout
	echo "TEST TIMEOUT - triggering crash"
	echo c > /proc/sysrq-trigger
    ) &
fi

cd /root

set +e
ret=0
while [[ $ret = 0 ]]; do
    run_tests $tests
    ret=$?
    [[ $ktest_loop = 1 ]] || break
done

copy_to_host
check_taint

if [[ $ret = 0 ]]; then
    echo "TEST SUCCESS"
else
    echo "TEST FAILED"
fi

exit 0
